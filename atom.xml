<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Leah&#39;s blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-08-04T14:39:29.142Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Leah Zheng</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>10-Javascript显式和隐式类型转换</title>
    <link href="http://yoursite.com/2020/08/02/19-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E8%BD%AC%E6%8D%A2/"/>
    <id>http://yoursite.com/2020/08/02/19-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E8%BD%AC%E6%8D%A2/</id>
    <published>2020-08-02T04:23:43.000Z</published>
    <updated>2020-08-04T14:39:29.142Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="显式类型转换"><a href="#显式类型转换" class="headerlink" title="显式类型转换"></a>显式类型转换</h2><h3 id="1-Number"><a href="#1-Number" class="headerlink" title="1.Number()"></a>1.Number()</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Number(true&#x2F;false)  &#x2F;&#x2F; 1&#x2F;0</span><br><span class="line">Number(null)   &#x2F;&#x2F; 0</span><br><span class="line">Number(undefined)&#x2F;&#x2F; NaN</span><br><span class="line">Number(&#39;a&#39;)   &#x2F;&#x2F; NaN</span><br><span class="line">Number(&#39;1a&#39;) &#x2F;&#x2F; NaN</span><br></pre></td></tr></table></figure><h2 id="2-praseInt"><a href="#2-praseInt" class="headerlink" title="2.praseInt()"></a>2.praseInt()</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">praseInt(true&#x2F;false) &#x2F;&#x2F; NaN</span><br><span class="line">praseInt(null)  &#x2F;&#x2F; 0</span><br><span class="line">praseInt(undefined)  &#x2F;&#x2F; NaN</span><br><span class="line">praseInt(NaN) &#x2F;&#x2F; NaN</span><br><span class="line">praseInt(&#39;abc123&#39;)   &#x2F;&#x2F; NaN</span><br><span class="line">praseInt(&#39;123abc&#39;)   &#x2F;&#x2F; 123</span><br></pre></td></tr></table></figure><h2 id="3-Boolean"><a href="#3-Boolean" class="headerlink" title="3.Boolean()"></a>3.Boolean()</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Boolean(1&#x2F;0)&#x2F;&#x2F; ture&#x2F;false</span><br><span class="line">Boolean(null)&#x2F;&#x2F; false</span><br><span class="line">Boolean(undefined)  &#x2F;&#x2F; false</span><br><span class="line">Boolean(NaN)&#x2F;&#x2F; false</span><br><span class="line">Boolean(&quot;&quot;)&#x2F;&#x2F; false</span><br><span class="line">Boolean(0)&#x2F;&#x2F; false</span><br><span class="line">Boolean(false)&#x2F;&#x2F; false</span><br><span class="line">其他都是true</span><br></pre></td></tr></table></figure><p><strong>注意</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">undefined.toString()和null.toString()都会报错</span><br></pre></td></tr></table></figure><h2 id="隐式类型转换"><a href="#隐式类型转换" class="headerlink" title="隐式类型转换"></a>隐式类型转换</h2><h4 id="隐式转成number"><a href="#隐式转成number" class="headerlink" title="隐式转成number"></a>隐式转成number</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">+;-;*;&#x2F;;%;</span><br><span class="line">++;--;&#x3D;&#x3D;;!&#x3D;;</span><br><span class="line">&gt;;&lt;;&lt;&#x3D;;&gt;&#x3D;;</span><br><span class="line">补充：undefined&#x3D;&#x3D;null</span><br></pre></td></tr></table></figure><h3 id="isNaN"><a href="#isNaN" class="headerlink" title="isNaN()"></a>isNaN()</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">isNaN(NaN)&#x2F;&#x2F;true</span><br><span class="line">isNaN(123)&#x2F;&#x2F;false</span><br><span class="line">isNaN(&#39;123&#39;)&#x2F;&#x2F;false</span><br><span class="line">isNaN(undefined)&#x2F;&#x2F;true</span><br><span class="line">isNaN(null)&#x2F;&#x2F;false</span><br><span class="line">isNaN(&#39;a&#39;)&#x2F;&#x2F;true</span><br><span class="line">number &#x3D;&gt;isNaN &#x3D;&gt;boo</span><br></pre></td></tr></table></figure><h2 id="typeof-判断类型"><a href="#typeof-判断类型" class="headerlink" title="typeof()判断类型"></a>typeof()判断类型</h2><ol><li>123 =&gt; number</li><li>‘123’ =&gt; string</li><li>{123},[123],null =&gt;object</li><li>function(){} =&gt;function</li><li>undefined</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">typeof(1-&#39;1&#39;) &#x2F;&#x2F; number</span><br><span class="line">typeof(&#39;1&#39;-&#39;1&#39;)&#x2F;&#x2F;number</span><br><span class="line">typeof(1)&#x2F;&#x2F;number</span><br><span class="line">typeof(typeof(1))&#x2F;&#x2F;string</span><br><span class="line">typeof(undefined)&#x2F;&#x2F;undefined</span><br><span class="line">typeof(typeof(undefined))&#x2F;&#x2F;string</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="数据类型" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    
    
      <category term="数据类型" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>vue解决跨域问题</title>
    <link href="http://yoursite.com/2020/08/01/18-vue%E8%A7%A3%E5%86%B3%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2020/08/01/18-vue%E8%A7%A3%E5%86%B3%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98/</id>
    <published>2020-08-01T08:14:35.000Z</published>
    <updated>2020-08-03T12:29:46.058Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><strong>一.什么是跨域</strong></p><p>跨域问题的出现是因为浏览器的同源策略问题，所谓同源:就是两个页面具有相同的协议（protocol），主机（host）和端口号（port），它是浏览器最核心也是最基本的功能，如果没有同源策略我们的浏览器将会十分的不安全，随时都可能受到攻击。</p><p>当我们请求一个接口的时候，出现如：Access-Control-Allow-Origin 字眼的时候说明请求跨域了</p><p><img src= "/img/loading.gif" data-src="https://img2018.cnblogs.com/i-beta/1649717/202002/1649717-20200227142258131-1409861315.png" alt=""></p><p><strong>二.如何解决跨域问题</strong></p><p>在vue项目根目录下找到vue.config.js文件（如果没有该文件则自己创建），在proxy中设置跨域</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">devServer: &#123;</span><br><span class="line">    proxy: &#123;  &#x2F;&#x2F;配置跨域</span><br><span class="line">      &#39;&#x2F;api&#39;: &#123;</span><br><span class="line">        target: &#39;http:&#x2F;&#x2F;121.121.67.254:8185&#x2F;&#39;,  &#x2F;&#x2F;这里后台的地址模拟的;应该填写你们真实的后台接口</span><br><span class="line">        changOrigin: true,  &#x2F;&#x2F;允许跨域</span><br><span class="line">        pathRewrite: &#123;</span><br><span class="line">          &#x2F;* 重写路径，当我们在浏览器中看到请求的地址为：http:&#x2F;&#x2F;localhost:8080&#x2F;api&#x2F;core&#x2F;getData&#x2F;userInfo 时</span><br><span class="line">            实际上访问的地址是：http:&#x2F;&#x2F;121.121.67.254:8185&#x2F;core&#x2F;getData&#x2F;userInfo,因为重写了 &#x2F;api</span><br><span class="line">           *&#x2F;</span><br><span class="line">          &#39;^&#x2F;api&#39;: &#39;&#39; </span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure><p><strong>在vue中使用proxy进行跨域的原理是：将域名发送给本地的服务器（启动vue项目的服务,loclahost:8080），再由本地的服务器去请求真正的服务器。</strong></p><p>以下是我在开发vue项目中实现跨域的步骤：</p><p>　　1.在proxy中设置要访问的地址，并重写/api为空的字符串，因为我们真正请求的地址是没有带/api，这个重写很重要!!!</p><p>　　<img src= "/img/loading.gif" data-src="https://img2018.cnblogs.com/i-beta/1649717/202002/1649717-20200227144905470-1085262547.png" alt="img"></p><p> 　2.在创建axios实例的时候将baseURL设置为/api ,这时候我们的跨域就已经完成了。</p><p>　　<img src= "/img/loading.gif" data-src="https://img2018.cnblogs.com/i-beta/1649717/202002/1649717-20200227145106938-1311841373.png" alt="img"></p><p> 　3. 假如请求的真正地址为：<a href="http://121.121.67.254:8185/core/getdata/userInfo,但我们在浏览器上会看到是这样的：" target="_blank" rel="noopener">http://121.121.67.254:8185/core/getdata/userInfo,但我们在浏览器上会看到是这样的：</a> <a href="http://localhost:8080/api/core/getData/userInfo" target="_blank" rel="noopener">http://localhost:8080/api/core/getData/userInfo</a> ,多了个/api，但并不影响我们请求数据。</p><p>　　<img src= "/img/loading.gif" data-src="https://img2018.cnblogs.com/i-beta/1649717/202002/1649717-20200227151147818-885350634.png" alt="img"></p><p><strong>注意：当修改了vue.config.js中的内容后，一定要重新启动服务yarn start 或者npm run dev之后，修改的内容才会生效</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="VUE" scheme="http://yoursite.com/categories/VUE/"/>
    
      <category term="跨域" scheme="http://yoursite.com/categories/VUE/%E8%B7%A8%E5%9F%9F/"/>
    
    
      <category term="VUE" scheme="http://yoursite.com/tags/VUE/"/>
    
      <category term="跨域" scheme="http://yoursite.com/tags/%E8%B7%A8%E5%9F%9F/"/>
    
  </entry>
  
  <entry>
    <title>实现一个sleep函数</title>
    <link href="http://yoursite.com/2020/07/29/17-%E5%AE%9E%E7%8E%B0sleep%E5%87%BD%E6%95%B0/"/>
    <id>http://yoursite.com/2020/07/29/17-%E5%AE%9E%E7%8E%B0sleep%E5%87%BD%E6%95%B0/</id>
    <published>2020-07-29T08:12:32.000Z</published>
    <updated>2020-08-01T13:23:52.419Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="实现一个sleep函数，比如sleep-1000-意味着等待1000毫秒，可以从Promise、Generator、Async-Await等角度实现。"><a href="#实现一个sleep函数，比如sleep-1000-意味着等待1000毫秒，可以从Promise、Generator、Async-Await等角度实现。" class="headerlink" title="实现一个sleep函数，比如sleep(1000)意味着等待1000毫秒，可以从Promise、Generator、Async/Await等角度实现。"></a>实现一个sleep函数，比如sleep(1000)意味着等待1000毫秒，可以从Promise、Generator、Async/Await等角度实现。</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function sleep(ms) &#123;</span><br><span class="line">return new Promise(resolve&#x3D;&gt;&#123;</span><br><span class="line"> setInterval(resolve,ms)</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">(async()&#x3D;&gt;&#123;</span><br><span class="line">console.log(111)</span><br><span class="line">await sleep(2000)</span><br><span class="line">console.log(222)</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="E6" scheme="http://yoursite.com/categories/E6/"/>
    
      <category term="Promise" scheme="http://yoursite.com/categories/E6/Promise/"/>
    
      <category term="async/await" scheme="http://yoursite.com/categories/E6/Promise/async-await/"/>
    
    
      <category term="Promise" scheme="http://yoursite.com/tags/Promise/"/>
    
      <category term="E6" scheme="http://yoursite.com/tags/E6/"/>
    
      <category term="async/await" scheme="http://yoursite.com/tags/async-await/"/>
    
  </entry>
  
  <entry>
    <title>09-对TCP三次握手和四次挥手的理解</title>
    <link href="http://yoursite.com/2020/07/28/16-%E5%AF%B9TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%92%8C%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%E7%9A%84%E7%90%86%E8%A7%A3/"/>
    <id>http://yoursite.com/2020/07/28/16-%E5%AF%B9TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%92%8C%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%E7%9A%84%E7%90%86%E8%A7%A3/</id>
    <published>2020-07-28T05:54:14.000Z</published>
    <updated>2020-08-01T13:24:51.533Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="建立连接-3-way-handshake"><a href="#建立连接-3-way-handshake" class="headerlink" title="建立连接 3-way handshake"></a>建立连接 3-way handshake</h2><p>客户端给服务器发送SYN（同步序列编号n）询问能否建立连接，服务器返回ACK（确认字符）+SYN（同步序列n+1），客户端再返回ACK消息响应，这样客户端就和服务器就建立了连接。</p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/08/01/a81x1g.png" alt=""></p><h2 id="主动断开连接-4-times-close"><a href="#主动断开连接-4-times-close" class="headerlink" title="主动断开连接 4-times close"></a>主动断开连接 4-times close</h2><p>客户端向服务器发送FIN:1,SEQ:n询问是否断开连接，服务端第一次回应ACK:n+1表示收到断开请求,第二次再返回FIN:1和SEQ：m告诉客服端已经准备好断开连接了，客户端最后返回ACK:m+1响应收到并断开连接。</p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/08/01/a81zcQ.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="HTTP" scheme="http://yoursite.com/categories/HTTP/"/>
    
    
      <category term="HTTP" scheme="http://yoursite.com/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>判断输出代码的执行结果并解释为什么</title>
    <link href="http://yoursite.com/2020/07/28/15-%E5%88%A4%E6%96%AD%E8%BE%93%E5%87%BA%E4%BB%A3%E7%A0%81%E7%9A%84%E6%89%A7%E8%A1%8C%E7%BB%93%E6%9E%9C%E5%B9%B6%E8%A7%A3%E9%87%8A%E4%B8%BA%E4%BB%80%E4%B9%88/"/>
    <id>http://yoursite.com/2020/07/28/15-%E5%88%A4%E6%96%AD%E8%BE%93%E5%87%BA%E4%BB%A3%E7%A0%81%E7%9A%84%E6%89%A7%E8%A1%8C%E7%BB%93%E6%9E%9C%E5%B9%B6%E8%A7%A3%E9%87%8A%E4%B8%BA%E4%BB%80%E4%B9%88/</id>
    <published>2020-07-28T05:54:14.000Z</published>
    <updated>2020-08-01T12:54:06.981Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var a &#x3D; &#123;n:1&#125;;</span><br><span class="line">var b &#x3D; a ;</span><br><span class="line">a.x &#x3D; a &#x3D; &#123;n : 2&#125;</span><br><span class="line"></span><br><span class="line">console.log(a.x)</span><br><span class="line">console.log(b.x)</span><br></pre></td></tr></table></figure><h5 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h5><p>这道题的关键知识点是连等，首先我们要知道连等开始之前程序会把所有的引用都保存下来，连等的过程中，这些值是保持不变的，等到整个连等都完事了，再一块儿变。</p><p>这是我画的图解：</p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/08/01/a3zXWD.png" alt=""></p><h5 id="输出结果："><a href="#输出结果：" class="headerlink" title="输出结果："></a>输出结果：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">console.log(a.x)  &#x2F;&#x2F; undefined</span><br><span class="line">console.log(b.x)  &#x2F;&#x2F; x:&#123;n:2&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="连等" scheme="http://yoursite.com/categories/%E8%BF%9E%E7%AD%89/"/>
    
    
      <category term="连等" scheme="http://yoursite.com/tags/%E8%BF%9E%E7%AD%89/"/>
    
  </entry>
  
  <entry>
    <title>08-HTTP缓存控制</title>
    <link href="http://yoursite.com/2020/07/27/14-HTTP%E7%BC%93%E5%AD%98%E6%8E%A7%E5%88%B6/"/>
    <id>http://yoursite.com/2020/07/27/14-HTTP%E7%BC%93%E5%AD%98%E6%8E%A7%E5%88%B6/</id>
    <published>2020-07-27T11:42:36.000Z</published>
    <updated>2020-07-27T15:02:01.377Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>HTTP缓存作用范围：从浏览器第一次请求到第二次浏览器响应，至少需要两次http请求。</p><p>HTTP缓存能够帮助服务器提升并发性能，很多资源不需要重复请求服务器，通过浏览器缓存就能获取到。</p><p>浏览器缓存分为：<strong>强缓存</strong>和<strong>协商缓存</strong></p><h4 id="强缓存"><a href="#强缓存" class="headerlink" title="强缓存"></a>强缓存</h4><p>不用发送请求到服务器就能获取到缓存文件</p><p><strong>如何判断强缓存</strong>：状态码为200OK，from cache</p><p>强缓存是利用http的返回头中的Expires和cache-Contrl来控制的，用来表示资源的缓存时间</p><h5 id="为什么有了Expires还要有cache-Contrl？"><a href="#为什么有了Expires还要有cache-Contrl？" class="headerlink" title="为什么有了Expires还要有cache-Contrl？"></a>为什么有了Expires还要有cache-Contrl？</h5><p>因为Expires是绝对时间，存在服务器与客户端时间不同步的问题。而cache-Contrl是相对时间，是相对于第一次请求的时间计算的。</p><p>cache-Contrl:max-age=9999</p><h4 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h4><p>发送请求到服务器，服务器判断本地缓存是否更新，若可以使用，服务器则不返回资源信息，浏览器继续从缓存中获取资源。</p><p><strong>判断协商缓存</strong>：状态码304 利用http返回头中的last-modify(第一次请求服务器返回)/if-modify-since(第二次浏览器发送请求)或Etag/if-none-match(返回唯一的校验码) </p><h5 id="为什么有了lats-modify还要有Etag？"><a href="#为什么有了lats-modify还要有Etag？" class="headerlink" title="为什么有了lats-modify还要有Etag？"></a>为什么有了lats-modify还要有Etag？</h5><p>因为last-modify的时间精确到秒，若是比秒更短的时间则无法判断，存在时间精度问题。而Etag返回的是唯一的校验码，每次更新缓存就会改变。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="HTTP" scheme="http://yoursite.com/categories/HTTP/"/>
    
    
      <category term="HTTP" scheme="http://yoursite.com/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>07-HTTP 基本概念</title>
    <link href="http://yoursite.com/2020/07/26/13-HTTP%20%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"/>
    <id>http://yoursite.com/2020/07/26/13-HTTP%20%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</id>
    <published>2020-07-26T12:12:45.000Z</published>
    <updated>2020-07-26T14:02:17.899Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="HTTP-是什么？描述一下"><a href="#HTTP-是什么？描述一下" class="headerlink" title="HTTP 是什么？描述一下"></a>HTTP 是什么？描述一下</h2><ul><li>HTTP 是超文本传输协议，也就是HyperText Transfer Protocol。</li></ul><h2 id="能否详细解释「超文本传输协议」？"><a href="#能否详细解释「超文本传输协议」？" class="headerlink" title="能否详细解释「超文本传输协议」？"></a>能否详细解释「超文本传输协议」？</h2><ul><li><p>HTTP的名字「超文本协议传输」，它可以拆成三个部分：</p><ul><li><p>超文本</p></li><li><p>传输</p></li><li><p>协议</p></li></ul></li><li><p>HTTP 是一个在计算机世界里专门在「两点」之间「传输」文字、图片、音频、视频等「超文本」数据的「约定和规范」。</p></li></ul><ul><li>那「HTTP 是用于从互联网服务器传输超文本到本地浏览器的协议HTTP」 ，这种说法正确吗？<ul><li>这种说法是不正确的。因为也可以是「服务器&lt; – &gt;服务器」，所以采用两点之间的描述会更准确。</li></ul></li></ul><h2 id="HTTP-常见的状态码，有哪些？"><a href="#HTTP-常见的状态码，有哪些？" class="headerlink" title="HTTP 常见的状态码，有哪些？"></a>HTTP 常见的状态码，有哪些？</h2><ul><li><p>1xx</p><ul><li>1xx 类状态码属于提示信息，是协议处理中的一种中间状态，实际用到的比较少。</li></ul></li><li><p>2xx</p><ul><li><p>2xx 类状态码表示服务器成功处理了客户端的请求，也是我们最愿意看到的状态。</p></li><li><p>「200 OK」是最常见的成功状态码，表示一切正常。如果是非 HEAD 请求，服务器返回的响应头都会有 body 数据。</p></li><li><p>「204 No Content」也是常见的成功状态码，与 200 OK 基本相同，但响应头没有 body 数据。</p></li><li><p>「206 Partial Content」是应用于 HTTP 分块下载或断电续传，表示响应返回的 body 数据并不是资源的全部，而是其中的一部分，也是服务器处理成功的状态。</p></li></ul></li><li><p>3xx</p><ul><li><p>3xx 类状态码表示客户端请求的资源发送了变动，需要客户端用新的 URL 重新发送请求获取资源，也就是重定向。</p></li><li><p>「301 Moved Permanently」表示永久重定向，说明请求的资源已经不存在了，需改用新的 URL 再次访问。</p></li><li><p>「302 Moved Permanently」表示临时重定向，说明请求的资源还在，但暂时需要用另一个 URL 来访问。</p></li><li><p>301 和 302 都会在响应头里使用字段 Location，指明后续要跳转的 URL，浏览器会自动重定向新的 URL。</p></li><li><p>「304 Not Modified」不具有跳转的含义，表示资源未修改，重定向已存在的缓冲文件，也称缓存重定向，用于缓存控制。</p></li></ul></li><li><p>4xx</p><ul><li><p>4xx 类状态码表示客户端发送的报文有误，服务器无法处理，也就是错误码的含义。</p></li><li><p>「400 Bad Request」表示客户端请求的报文有错误，但只是个笼统的错误。</p></li><li><p>「403 Forbidden」表示服务器禁止访问资源，并不是客户端的请求出错。</p></li><li><p>「404 Not Found」表示请求的资源在服务器上不存在或未找到，所以无法提供给客户端。</p></li></ul></li><li><p>5xx</p><p><img src= "/img/loading.gif" data-src="https://api2.mubu.com/v3/document_image/28295742-106c-437f-89ae-2a75c243ad8b-3807603.jpg" alt=""></p><ul><li><p>5xx 类状态码表示客户端请求报文正确，但是服务器处理时内部发生了错误，属于服务器端的错误码。</p></li><li><p>「500 Internal Server Error」与 400 类型，是个笼统通用的错误码，服务器发生了什么错误，我们并不知道。</p></li><li><p>「501 Not Implemented」表示客户端请求的功能还不支持，类似“即将开业，敬请期待”的意思。</p></li><li><p>「502 Bad Gateway」通常是服务器作为网关或代理时返回的错误码，表示服务器自身工作正常，访问后端服务器发生了错误。</p></li><li><p>「503 Service Unavailable」表示服务器当前很忙，暂时无法响应服务器，类似“网络服务正忙，请稍后重试”的意思。</p></li></ul></li></ul><h2 id="http-常见字段有哪些？"><a href="#http-常见字段有哪些？" class="headerlink" title="http 常见字段有哪些？"></a>http 常见字段有哪些？</h2><ul><li><p>Host</p><ul><li><p>客户端发送请求时，用来指定服务器的域名。<img src= "/img/loading.gif" data-src="https://api2.mubu.com/v3/document_image/fb86d6fd-e6bd-41cf-aece-fed0037dcf81-3807603.jpg" alt="img"></p></li><li><p>Host: <a href="http://www.A.com" target="_blank" rel="noopener">http://www.A.com</a></p></li><li><p>有了 Host 字段，就可以将请求发往「同一台」服务器上的不同网站。</p></li></ul></li><li><p>Content-Length 字段</p><ul><li><p>服务器在返回数据时，会有 Content-Length 字段，表明本次回应的数据长度。<img src= "/img/loading.gif" data-src="https://api2.mubu.com/v3/document_image/2ca4f141-26f2-48bf-a4e7-6e718db6b056-3807603.jpg" alt="img"></p></li><li><p>Content-Length: 1000</p></li><li><p>如上面则是告诉浏览器，本次服务器回应的数据长度是 1000 个字节，后面的字节就属于下一个回应了。</p></li></ul></li><li><p>Connection 字段</p><ul><li><p>Connection 字段最常用于客户端要求服务器使用 TCP 持久连接，以便其他请求复用。<img src= "/img/loading.gif" data-src="https://api2.mubu.com/v3/document_image/e76e6254-5918-4759-a25e-6b0f33ca9968-3807603.jpg" alt="img"></p></li><li><p>HTTP/1.1 版本的默认连接都是持久连接，但为了兼容老版本的 HTTP，需要指定 Connection 首部字段的值为 Keep-Alive。</p></li><li><p>Connection: keep-alive</p></li><li><p>一个可以复用的 TCP 连接就建立了，直到客户端或服务器主动关闭连接。但是，这不是标准字段。</p></li></ul></li><li><p>Content-Type 字段</p><ul><li><p>Content-Type 字段用于服务器回应时，告诉客户端，本次数据是什么格式。<img src= "/img/loading.gif" data-src="https://api2.mubu.com/v3/document_image/70955d3f-0d65-4e0c-afe7-dbbdbcc4fe59-3807603.jpg" alt="img"></p></li><li><p>Content-Type: text/html; charset=utf-8</p></li><li><p>上面的类型表明，发送的是网页，而且编码是UTF-8。</p></li><li><p>客户端请求的时候，可以使用 Accept 字段声明自己可以接受哪些数据格式。</p></li><li><p>Accept: <em>/</em></p></li><li><p>上面代码中，客户端声明自己可以接受任何格式的数据。</p></li></ul></li><li><p>Content-Encoding 字段</p><ul><li><p>Content-Encoding 字段说明数据的压缩方法。表示服务器返回的数据使用了什么压缩格式<img src= "/img/loading.gif" data-src="https://api2.mubu.com/v3/document_image/e55a7e13-db1f-4307-9b91-39c430d196cd-3807603.jpg" alt="img"></p></li><li><p>Content-Encoding: gzip</p></li><li><p>上面表示服务器返回的数据采用了 gzip 方式压缩，告知客户端需要用此方式解压。</p></li><li><p>客户端在请求时，用 Accept-Encoding 字段说明自己可以接受哪些压缩方法。</p></li><li><p>Accept-Encoding: gzip, deflate</p></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="HTTP" scheme="http://yoursite.com/categories/HTTP/"/>
    
    
      <category term="HTTP" scheme="http://yoursite.com/tags/HTTP/"/>
    
      <category term="状态码" scheme="http://yoursite.com/tags/%E7%8A%B6%E6%80%81%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>06-正则表达式知识整理</title>
    <link href="http://yoursite.com/2020/07/24/11-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>http://yoursite.com/2020/07/24/11-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</id>
    <published>2020-07-24T14:36:56.000Z</published>
    <updated>2020-07-24T15:58:10.958Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><strong>正则</strong>：是一个用来处理字符串的规则，由元字符和修字符组成</p><ol><li>正则只能用来处理字符串</li><li>处理一般包括两个方面：<ol><li>验证当前字符出是否符合某个规则 “正则匹配”</li><li>把一个字符串中符合规则的字符获取到 “正则捕获”</li></ol></li></ol><p><strong>创建正则的两种方式：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let reg &#x3D; new RegExp(&quot;^\\d+$&quot;,&quot;g&quot;); &#x2F;&#x2F;构造函数</span><br><span class="line">let reg &#x3D; &#x2F;^\d+$&#x2F;g;  &#x2F;&#x2F;字面量方式</span><br></pre></td></tr></table></figure><p><strong>有效数字</strong></p><p>1.正数 负数 零 小数 正数</p><p>let reg = /^[+-]?(\d|([1-9]\d+))(\ .\d+)?$/;</p><p><strong>手机号码</strong></p><p>1.十一位 以1开头 </p><p>let reg = /^1/d{10}$/</p><p><strong>中文姓名</strong></p><p>1.中文汉字   [\u4E00-\u9FA5]</p><p>let reg = /^ [\u4E00-\u9FA5]{2,}(·[\u4E00-\u9FA5]{2,})?$/</p><p><strong>邮箱</strong></p><p>let reg = /^/w+([.-]/w+)*@[a-zA-Z0-9] +([-.] [a-zA-Z0-9]+) *(/. [a-zA-Z0-9]+)]$/</p><p><strong>正则捕获</strong>：把一个字符串中和正则匹配的部分获取到</p><p>【正则】 exec test</p><p>【字符串】replace split match</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let str &#x3D; &#39;dnfei123&#39;</span><br><span class="line">let reg &#x3D; &#x2F;\d+&#x2F;</span><br><span class="line">console.log(reg.test(str)) &#x2F;&#x2F;true or false</span><br><span class="line">console.log(reg.exec(str)) &#x2F;&#x2F;null or array</span><br></pre></td></tr></table></figure><h3 id="基于EXEC可以实现正则的捕获"><a href="#基于EXEC可以实现正则的捕获" class="headerlink" title="基于EXEC可以实现正则的捕获"></a>基于EXEC可以实现正则的捕获</h3><ol><li><p>如果当前正则和字符串不匹配，捕获的结果是null</p></li><li><p>如果匹配，捕获的结果是一个数组</p><p>​    0：大正则捕获的内容</p><p>​    index：正则捕获的起使索引</p><p>​    input：原始操作的字符串</p></li><li><p>执行一次exec只能捕获到第一个和正则匹配的内容，其余匹配内容没有捕获到，执行多次也只能捕获第一个匹配的内容</p><p>==》正则的捕获有<strong>懒惰性</strong>：只能捕获到第一个匹配的内容，剩余的默认捕获不到</p><h3 id="自己封装一个方法能够一次捕获全部匹配结果"><a href="#自己封装一个方法能够一次捕获全部匹配结果" class="headerlink" title="自己封装一个方法能够一次捕获全部匹配结果"></a>自己封装一个方法能够一次捕获全部匹配结果</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">RegExp.prototype.myExecall &#x3D; function(str) &#123;</span><br><span class="line">if(!this.glabal)&#123;</span><br><span class="line">return this.exec(str);</span><br><span class="line">&#125;</span><br><span class="line">let result &#x3D; [],</span><br><span class="line">valAry &#x3D; this.exec(str);</span><br><span class="line">while(valAry) &#123; </span><br><span class="line">result.push(valAry[0]) &#x3D;&gt;把每次正则捕获到的结果的第一项存储到容器中</span><br><span class="line">valAry &#x3D; this.exec(str);</span><br><span class="line">&#125;</span><br><span class="line">return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="分组捕获-exec与match的局限性"><a href="#分组捕获-exec与match的局限性" class="headerlink" title="分组捕获-exec与match的局限性"></a>分组捕获-exec与match的局限性</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let str &#x3D; &#39;fheufhr&#123;2020&#125;fjirj&#123;2021&#125;&#39;,</span><br><span class="line">reg &#x3D; &#x2F;\&#123;(\d+)\&#125;&#x2F;g  &#x2F;&#x2F;&#x3D;&gt;大括号有特殊含义</span><br><span class="line">&#x2F;&#x2F;console.log(reg.exec(str))  &#x3D;&gt;[&#39;&#123;2020&#125;&#39;,&#39;2020&#39;]</span><br></pre></td></tr></table></figure><p>在正则捕获的时候，如果正则中存在分组，捕获的时候不仅仅把大正则匹配到的字符捕获到（数组第一项），也会把小分组匹配的内容也单独抽取出来（数组第二项开始就是小分组捕获的内容） =》<strong>分组捕获</strong> ，而/\ {(?:\d+)\ }/g中的<strong>?:</strong>可以用来阻止分组捕获内容的“<strong>只匹配不捕获</strong>”</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(str.match(reg));&#x2F;&#x2F;&#x3D;&gt;[&quot;&#123;2020&#125;&quot;,&quot;&#123;2021&#125;&quot;]</span><br></pre></td></tr></table></figure><p>match方法也有自己的局限性，在正则设置了g的情况下，基于match捕获的内容只有大正则匹配的，小分组的内容没有单独抽取出来（不设置g的情况下和执行exec一样）</p><h3 id="test与exec"><a href="#test与exec" class="headerlink" title="test与exec"></a>test与exec</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let str &#x3D; &#39;fheufhr2020fjirj2021&#39;,</span><br><span class="line">reg &#x3D; &#x2F;\d+&#x2F;g  </span><br><span class="line">console.log(reg.test(str))  &#x3D;&gt;true</span><br><span class="line">console.log(reg.lastIndex)  &#x3D;&gt;7 &#x2F;&#x2F;基于test进行匹配的时候，如果设置了g，test匹配也相当于捕获，修改了lastindex的值</span><br><span class="line">console.log(reg.exec(str))  &#x3D;&gt;[&#39;2021&#39;]</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let str &#x3D; &#39;fheufhr2020fjirj2021&#39;,</span><br><span class="line">reg &#x3D; &#x2F;\d+&#x2F;g  </span><br><span class="line">console.log(reg.exec(str))  &#x3D;&gt;[&#39;2020&#39;] &#x2F;&#x2F;把reg.lastindex的值修改了</span><br><span class="line">console.log(reg.exec(str))  &#x3D;&gt;[&#39;2021&#39;] &#x2F;&#x2F;虽然捕获的不是同一个字符串，但是正则是同一个，上一次正则处理的时候修改了lastindex，也会对下一次匹配的新的字符串产生影响</span><br></pre></td></tr></table></figure><h3 id="时间字符串格式化"><a href="#时间字符串格式化" class="headerlink" title="时间字符串格式化"></a>时间字符串格式化</h3><p>”2020/07/20 20:13:23“  =&gt;”07-20 20:13”</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let str &#x3D; &quot;2020&#x2F;07&#x2F;20 20:13:23&quot;,</span><br><span class="line">arr &#x3D; str.split(&#x2F;(?:\&#x2F;| |:)&#x2F;g)</span><br><span class="line">console.log(arr) &#x3D;&gt; [&quot;2020&quot;, &quot;07&quot;, &quot;20&quot;, &quot;20&quot;, &quot;13&quot;, &quot;23&quot;]</span><br><span class="line">let [,mouth,day,hours,minutes] &#x3D; arr,</span><br><span class="line">result &#x3D; &#96;$&#123;mouth&#125;-$&#123;day&#125; $&#123;hours&#125;:$&#123;minutes&#125;&#96;</span><br><span class="line">&#x3D;&gt;&quot;07-20 20:13&quot;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">let str &#x3D; &quot;2020&#x2F;7&#x2F;20 20:13:23&quot;</span><br><span class="line">&#x2F;&#x2F;获取时间字符串中所有的数字</span><br><span class="line">let arr &#x3D; str.match(&#x2F;\d+&#x2F;g).map(item&#x3D;&gt;&#123;</span><br><span class="line">&#x2F;&#x2F;&#x3D;&gt;map相对于foreach来说多了返回值，函数中return的是啥，就把当前数组中迭代的这一项替换成啥</span><br><span class="line">return item&lt;10?&#39;0&#39;+item :item; </span><br><span class="line">&#125;)</span><br><span class="line">&#x2F;&#x2F;指定最后想要的时间格式，基于这个数组的内容，帮你拼接好即可</span><br><span class="line">let template &#x3D; &#39;&#123;0&#125;年&#123;1&#125;月&#123;2&#125;日 &#123;3&#125;时&#123;4&#125;分&#123;5&#125;秒&#39;</span><br><span class="line">&#x2F;&#x2F;&#x3D;&gt;&#123;0&#125; &#x2F; 0 &#x3D;&gt;&#39;2020&#39; arr[0]</span><br><span class="line">&#x2F;&#x2F;&#x3D;&gt;&#123;1&#125; &#x2F; 1 &#x3D;&gt;&#39;07&#39; arr[1]...</span><br><span class="line">template &#x3D; template.replace(&#x2F;\&#123;(\d)\&#125;&#x2F;g,(...arg)&#x3D;&gt;&#123;</span><br><span class="line">let [,index] &#x3D; arg &#x2F;&#x2F;index:每次正则匹配小分组捕获的结果（也就是那个数字）</span><br><span class="line">    return arr[index];</span><br><span class="line">&#125;)</span><br><span class="line">console.log(template)</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/24/UxlJSO.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="RegExp" scheme="http://yoursite.com/categories/RegExp/"/>
    
    
      <category term="RegExp" scheme="http://yoursite.com/tags/RegExp/"/>
    
  </entry>
  
  <entry>
    <title>flex是什么？flex：1表示什么？</title>
    <link href="http://yoursite.com/2020/07/24/12-flex%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9Fflex%EF%BC%9A1%E8%A1%A8%E7%A4%BA%E4%BB%80%E4%B9%88%EF%BC%9F/"/>
    <id>http://yoursite.com/2020/07/24/12-flex%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9Fflex%EF%BC%9A1%E8%A1%A8%E7%A4%BA%E4%BB%80%E4%B9%88%EF%BC%9F/</id>
    <published>2020-07-24T14:36:56.000Z</published>
    <updated>2020-07-25T15:37:57.639Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>flex是三个属性的缩写，分别是flex-grow、flex-shrink、flex-basis。</p><p><strong>flex-grow表示项目的放大比例</strong></p><p>:one:默认为0，即使存在剩余空间也不会放大</p><p>:two:所有项目的flex-grow为1时，等分剩余空间</p><p>:three:flex-row为n的项目，占据的空间（放大的比例）是flex-grow为1的n倍</p><h5 id="flex-shrink表示项目的缩小比例"><a href="#flex-shrink表示项目的缩小比例" class="headerlink" title="flex-shrink表示项目的缩小比例"></a><strong>flex-shrink表示项目的缩小比例</strong></h5><p>:one:默认为1，当空间不足时，项目会自动缩小</p><p>:two:flex-shrink为0时，空间不足，项目不会缩小</p><p>:three: flex-shrink为n的项目，空间不足时缩小的比例是flex-shrink为1的n倍</p><h5 id="flex-basis表示在分配剩余空间之前，项目所占据的主轴空间大小"><a href="#flex-basis表示在分配剩余空间之前，项目所占据的主轴空间大小" class="headerlink" title="flex-basis表示在分配剩余空间之前，项目所占据的主轴空间大小"></a><strong>flex-basis表示在分配剩余空间之前，项目所占据的主轴空间大小</strong></h5><p>:one:默认为auto，即项目本身的大小</p><p>:two:设置后项目将占据固定空间</p><p>所以flex属性的默认值为：0 1 auto （不放大会缩小）</p><p>  <strong>flex为none</strong>：0 0 auto  （不放大也不缩小）</p><p>  <strong>flex为auto</strong>：1 1 auto  （放大且缩小）</p><p>因此flex：1即为flex-grow：1，经常用作自适应布局，将父容器的display：flex，侧边栏大小固定后，将内容区flex：1，内容区则会自动放大占满剩余空间。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="CSS" scheme="http://yoursite.com/categories/CSS/"/>
    
    
      <category term="CSS" scheme="http://yoursite.com/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>输出下面代码运行结果</title>
    <link href="http://yoursite.com/2020/07/23/10-%E8%BE%93%E5%87%BA%E4%B8%8B%E9%9D%A2%E4%BB%A3%E7%A0%81%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C/"/>
    <id>http://yoursite.com/2020/07/23/10-%E8%BE%93%E5%87%BA%E4%B8%8B%E9%9D%A2%E4%BB%A3%E7%A0%81%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C/</id>
    <published>2020-07-23T11:35:23.000Z</published>
    <updated>2020-07-23T13:28:42.223Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>输出下面代码运行结果</p><p>example 1</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var a &#x3D; &#123;&#125;，b&#x3D;&#39;123&#39;,c&#x3D;123;</span><br><span class="line">a[b]&#x3D;&#39;b&#39;;</span><br><span class="line">a[c]&#x3D;&#39;c&#39;;</span><br><span class="line">console.log(a[b]);</span><br></pre></td></tr></table></figure><p>example 2</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var a &#x3D; &#123;&#125;，b&#x3D;Symbol(&#39;123&#39;),c&#x3D;Symbol(&#39;123&#39;);</span><br><span class="line">a[b]&#x3D;&#39;b&#39;;</span><br><span class="line">a[c]&#x3D;&#39;c&#39;;</span><br><span class="line">console.log(a[b]);</span><br></pre></td></tr></table></figure><p>example 3</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var a &#x3D; &#123;&#125;，b&#x3D;&#123;key:&#39;123&#39;&#125;,c&#x3D;&#123;key:&#39;456&#39;&#125;;</span><br><span class="line">a[b]&#x3D;&#39;b&#39;;</span><br><span class="line">a[c]&#x3D;&#39;c&#39;;</span><br><span class="line">console.log(a[b]);</span><br></pre></td></tr></table></figure><p>答案：</p><ol><li><p>c  =&gt; 因为a[‘123’] == a[123]</p></li><li><p>b  =&gt;Symbol是ES6中新增的数据类型，typeof Smybol(‘123’) === Smybol,它创建出的值是唯一的</p><p>Smybol(‘123’) =！Smybol(‘123’) </p></li><li><p>c =&gt;  对象的属性名不能是一个对象，若是对象属性名，会默认转换为字符串</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">obj&#x3D;&#123;&#125; arr&#x3D;[11,22] obj[arr]&#x3D;33  obj&#x3D;&gt;&#123;&#39;11,22&#39;:33&#125;</span><br></pre></td></tr></table></figure><p>普通对象.toString() 调取的是Object.prototype上的方法(这个方法是用来检测数据类型的)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">obj&#x3D;&#123;&#125; obj.toString()&#x3D;&gt;&#39;[Object Object]&#39;</span><br><span class="line">obj[b]&#x3D;&#39;b&#39; &#x3D;&gt; obj[&#39;[Object Object]&#39;]&#x3D;&#39;b&#39;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
    
      <category term="prototype" scheme="http://yoursite.com/tags/prototype/"/>
    
      <category term="Symbol" scheme="http://yoursite.com/tags/Symbol/"/>
    
  </entry>
  
  <entry>
    <title>实现(5).add(3).minus(2)，使其结果为6</title>
    <link href="http://yoursite.com/2020/07/22/07-%E5%AE%9E%E7%8E%B0(5).add(3).minus(2)/"/>
    <id>http://yoursite.com/2020/07/22/07-%E5%AE%9E%E7%8E%B0(5).add(3).minus(2)/</id>
    <published>2020-07-22T12:35:23.000Z</published>
    <updated>2020-07-22T12:31:37.222Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">~function()&#123;</span><br><span class="line">&#x2F;&#x2F;每一个方法执行完，都要返回Number这个类的实例，这样才可以继续调取Number类原型中的方法</span><br><span class="line">function check(n)&#123;</span><br><span class="line">n &#x3D; Nunber(n);</span><br><span class="line">return isNaN(n)?0:n;</span><br><span class="line">&#125;</span><br><span class="line">function add(n)&#123;</span><br><span class="line">n &#x3D; check(n);</span><br><span class="line">return this+n;</span><br><span class="line">&#125;</span><br><span class="line">functino minus(n)&#123;</span><br><span class="line">n &#x3D; check(n);</span><br><span class="line">return this-n;</span><br><span class="line">&#125;</span><br><span class="line">Number.prototype.add &#x3D; add;</span><br><span class="line">Number.prototype.minus &#x3D; minus;</span><br><span class="line">&#x2F;*[add,minus].foreach(item&#x3D;&gt;&#123;</span><br><span class="line">Number.prototype[item]&#x3D;eval(item)</span><br><span class="line">&#125;)*&#x2F;</span><br><span class="line">&#125;();</span><br><span class="line">(5).add(3).minus(2)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="JS算法" scheme="http://yoursite.com/categories/JS%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="JS算法" scheme="http://yoursite.com/tags/JS%E7%AE%97%E6%B3%95/"/>
    
      <category term="prototype" scheme="http://yoursite.com/tags/prototype/"/>
    
  </entry>
  
  <entry>
    <title>如何把一个字符串的大小写取反</title>
    <link href="http://yoursite.com/2020/07/22/06-%E5%A6%82%E4%BD%95%E6%8A%8A%E4%B8%80%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%A4%A7%E5%B0%8F%E5%86%99%E5%8F%96%E5%8F%8D/"/>
    <id>http://yoursite.com/2020/07/22/06-%E5%A6%82%E4%BD%95%E6%8A%8A%E4%B8%80%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%A4%A7%E5%B0%8F%E5%86%99%E5%8F%96%E5%8F%8D/</id>
    <published>2020-07-22T12:28:08.000Z</published>
    <updated>2020-07-22T12:28:54.683Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="如何把一个字符串的大小写取反（大写变小写，小写变大写）"><a href="#如何把一个字符串的大小写取反（大写变小写，小写变大写）" class="headerlink" title="如何把一个字符串的大小写取反（大写变小写，小写变大写）"></a>如何把一个字符串的大小写取反（大写变小写，小写变大写）</h2><h4 id=""><a href="#" class="headerlink" title=""></a></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let str &#x3D; &#39;hfubH就U观看dhHUd耳机的H日e就&#39;</span><br><span class="line">&#x2F;&#x2F; content:每次正则匹配的结果</span><br><span class="line">&#x2F;&#x2F;把字母转换为大写后判断是否和之前一样，若一样则要转小写</span><br><span class="line">&#x2F;&#x2F;或者在ASCII表中找大写字母的取值范围(65-90)进行判断charCodeAt</span><br><span class="line">str.replace(&#x2F;[a-zA-Z]&#x2F;g,content&#x3D;&gt;&#123;</span><br><span class="line">return content.toUpperCase() &#x3D;&#x3D;&#x3D; content? content.toLowerCase() : content.toUpperCase();</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="JS算法" scheme="http://yoursite.com/categories/JS%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="JS算法" scheme="http://yoursite.com/tags/JS%E7%AE%97%E6%B3%95/"/>
    
      <category term="字符串" scheme="http://yoursite.com/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>实现一个字符串匹配算法</title>
    <link href="http://yoursite.com/2020/07/22/05-%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95/"/>
    <id>http://yoursite.com/2020/07/22/05-%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95/</id>
    <published>2020-07-22T12:23:08.000Z</published>
    <updated>2020-07-22T12:26:45.666Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="从字符串S中，查找是否存在字符串T，若存在返回所在位置，不存在返回-1（不能基于indexOf-includes等内置方法）"><a href="#从字符串S中，查找是否存在字符串T，若存在返回所在位置，不存在返回-1（不能基于indexOf-includes等内置方法）" class="headerlink" title="从字符串S中，查找是否存在字符串T，若存在返回所在位置，不存在返回-1（不能基于indexOf/includes等内置方法）"></a>从字符串S中，查找是否存在字符串T，若存在返回所在位置，不存在返回-1（不能基于indexOf/includes等内置方法）</h2><h4 id=""><a href="#" class="headerlink" title=""></a></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">~function()&#123;</span><br><span class="line">&#x2F;&#x2F;方法一 循环遍历</span><br><span class="line">&#x2F;*function myIndexOf(T) &#123;</span><br><span class="line">let lenS &#x3D; S.length,</span><br><span class="line">lenT &#x3D; T.length,</span><br><span class="line">res &#x3D; -1;</span><br><span class="line">if (lenT&gt;lenS) return -1;</span><br><span class="line">for(let i&#x3D;0;i&lt;&#x3D;lenS - lenT + 1;i++) &#123;</span><br><span class="line">if(this.substr(i,lenT) &#x3D;&#x3D;&#x3D; T) &#123;</span><br><span class="line">res &#x3D; i;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">return res;</span><br><span class="line">&#125;*&#x2F;</span><br><span class="line"></span><br><span class="line">--------------------------------------------</span><br><span class="line">    </span><br><span class="line">方法二 正则匹配</span><br><span class="line">&#x2F;*function myIndexOf(T)&#123;</span><br><span class="line">let reg &#x3D; new RegExp(T),</span><br><span class="line">res &#x3D; reg.exec(this);</span><br><span class="line">return res&#x3D;&#x3D;&#x3D;null ? -1：res.index; </span><br><span class="line">&#125;*&#x2F;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">String.prototype.myIndexOf &#x3D; myIndexOf();</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line">let S &#x3D; &#39;doujingtongmeme&#39;,</span><br><span class="line">T &#x3D; &#39;to&#39;;</span><br><span class="line">console.log(S.myIndexOf(T))</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="JS算法" scheme="http://yoursite.com/categories/JS%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="JS算法" scheme="http://yoursite.com/tags/JS%E7%AE%97%E6%B3%95/"/>
    
      <category term="字符串" scheme="http://yoursite.com/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>05-call和apply的区别是什么，哪个性能更好一些？</title>
    <link href="http://yoursite.com/2020/07/21/08-call%E5%92%8Capply%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88/"/>
    <id>http://yoursite.com/2020/07/21/08-call%E5%92%8Capply%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88/</id>
    <published>2020-07-21T12:55:23.000Z</published>
    <updated>2020-07-22T12:55:56.461Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>call和apply都是<strong>Function原型上</strong>的方法，而每个函数作为Function这个类的<strong>实例</strong>，可以调用原型上的call和apply方法。<br>call和apply都是用来改变this指向的，区别是call是传递参数时是<strong>一个一个传参</strong>，而apply要求把参数<strong>以数组的形式</strong>传递。<br>还有一个类似的方式bind()，bind也是改变this的指向，<strong>但没有立即执行函数</strong>，只是预先处理改变this指向。<br><strong>call的性能要比apply好一些</strong>，尤其是传递给函数的参数超过<strong>三个</strong>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let arr &#x3D; [1,2,3],</span><br><span class="line">obj &#x3D; &#123;&#125;;</span><br><span class="line">function fn(a,b,c) &#123;&#125;;</span><br><span class="line">fn.apply(obj,arr) &#x2F;&#x2F;a&#x3D;1,b&#x3D;2,c&#x3D;3</span><br><span class="line">fn.call(obj,arr) &#x2F;&#x2F;a&#x3D;[1,2,3] b&#x3D;c&#x3D;undefined</span><br><span class="line">fn.call(obj,..arr) &#x2F;&#x2F;基于es6的展开运算符能够实现把数组中的每一项一次传递给函数</span><br></pre></td></tr></table></figure><h4 id="补充："><a href="#补充：" class="headerlink" title="补充："></a>补充：</h4><h4 id="自己实现性能测试（只供参考）"><a href="#自己实现性能测试（只供参考）" class="headerlink" title="自己实现性能测试（只供参考）"></a>自己实现性能测试（只供参考）</h4><p>任何代码性能测试都是和测试环境有关的，例如CPU、内存、GPU等电脑当前性能不会有相同的情况，不同浏览器也会导致性能的不同。</p><h5 id="console-time可以测试出一段程序执行的时间"><a href="#console-time可以测试出一段程序执行的时间" class="headerlink" title="console.time可以测试出一段程序执行的时间"></a>console.time可以测试出一段程序执行的时间</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">console.time(&#39;a&#39;);</span><br><span class="line">for(let i&#x3D;0;i&lt;1000000000;i++) &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">console.timeEnd(&#39;a&#39;)</span><br></pre></td></tr></table></figure><p>console.profile()在火狐浏览器中安装fireBug,可以更精准的获取到程序的每一个步骤所消耗的时间</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="this" scheme="http://yoursite.com/categories/this/"/>
    
    
      <category term="this" scheme="http://yoursite.com/tags/this/"/>
    
  </entry>
  
  <entry>
    <title>04-箭头函数与普通函数的区别？</title>
    <link href="http://yoursite.com/2020/07/20/09-%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%E4%B8%8E%E6%99%AE%E9%80%9A%E5%87%BD%E6%95%B0%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://yoursite.com/2020/07/20/09-%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%E4%B8%8E%E6%99%AE%E9%80%9A%E5%87%BD%E6%95%B0%E7%9A%84%E5%8C%BA%E5%88%AB/</id>
    <published>2020-07-20T07:23:42.000Z</published>
    <updated>2020-07-22T12:46:12.353Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="箭头函数与普通函数的区别？构造函数可以使用new生成实例，那么箭头函数可以吗？为什么？"><a href="#箭头函数与普通函数的区别？构造函数可以使用new生成实例，那么箭头函数可以吗？为什么？" class="headerlink" title="箭头函数与普通函数的区别？构造函数可以使用new生成实例，那么箭头函数可以吗？为什么？"></a>箭头函数与普通函数的区别？构造函数可以使用new生成实例，那么箭头函数可以吗？为什么？</h2><h4 id="箭头函数与普通函数的区别："><a href="#箭头函数与普通函数的区别：" class="headerlink" title="箭头函数与普通函数的区别："></a>箭头函数与普通函数的区别：</h4><ol><li><p>箭头函数语法比普通函数更加简洁（ES6中每一种函数都可以使用形参赋默认值(x=0)和剩余运算符(…arg)）</p></li><li><p>箭头函数没有自己的this，它里面的this是继承函数所处上下文中的this（使用call/apply等任何方式都无法改变指向）</p></li><li><p>箭头函数中没有argument（类数组），只能基于…arg获取传递的参数集合（数组）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function fn(...arg) &#123;</span><br><span class="line">console.log(arg)</span><br><span class="line">&#125;</span><br><span class="line">fn(1,2,3) &#x2F;&#x2F; [1,2,3]</span><br><span class="line">-------------------------</span><br><span class="line">function add(...arg) &#123;</span><br><span class="line">return arg.reduce((m,n)&#x3D;&gt;m+n,0)</span><br><span class="line">&#125;</span><br><span class="line">add(1,2,3) &#x2F;&#x2F; 6</span><br></pre></td></tr></table></figure></li><li><p>箭头函数不能被new执行（因为箭头函数没有prototype也没有this）</p></li></ol><h4 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h4><p>把一个函数A作为实参传递给另一个函数B，函数B在执行的时候，可以把传递进来的函数A去执行（执行N次，可传值，可改this ）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function each(arr,callback) &#123;</span><br><span class="line">for(let i&#x3D;0;i&lt;arr.length;i++) &#123;</span><br><span class="line">let flag &#x3D; callback.call(arr,i,arr[i])</span><br><span class="line">if (flag &#x3D;&#x3D;&#x3D; false)&#123;</span><br><span class="line">break</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">each([10,20,30],function(index,item)&#123;</span><br><span class="line">if(index &gt;1) &#123;</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="ES6" scheme="http://yoursite.com/categories/ES6/"/>
    
    
      <category term="ES6" scheme="http://yoursite.com/tags/ES6/"/>
    
  </entry>
  
  <entry>
    <title>03-实现浏览器内多个标签页之间的通讯</title>
    <link href="http://yoursite.com/2020/07/19/04-%E6%B5%8F%E8%A7%88%E5%99%A8%E5%86%85%E5%A4%9A%E4%B8%AA%E6%A0%87%E7%AD%BE%E9%A1%B5%E4%B9%8B%E9%97%B4%E7%9A%84%E9%80%9A%E8%AE%AF/"/>
    <id>http://yoursite.com/2020/07/19/04-%E6%B5%8F%E8%A7%88%E5%99%A8%E5%86%85%E5%A4%9A%E4%B8%AA%E6%A0%87%E7%AD%BE%E9%A1%B5%E4%B9%8B%E9%97%B4%E7%9A%84%E9%80%9A%E8%AE%AF/</id>
    <published>2020-07-19T04:23:41.000Z</published>
    <updated>2020-07-20T04:23:41.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>实现多页通讯主要有利用浏览器储存和服务器方式</p><h3 id="知识考察点"><a href="#知识考察点" class="headerlink" title="知识考察点"></a>知识考察点</h3><p>什么是多页应用</p><p>两种浏览器存储方式实现多页间通讯</p><p>websoket和shareworker实现多页通讯</p><h3 id="方法一——调用localstorage"><a href="#方法一——调用localstorage" class="headerlink" title="方法一——调用localstorage"></a>方法一——调用localstorage</h3><p>页面一：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">window.onload &#x3D; ()&#x3D;&gt;&#123;</span><br><span class="line">var btnEle &#x3D; document.getElementById(&#39;btn&#39;);</span><br><span class="line">var nameEle &#x3D; document.getElementById(&#39;name&#39;);</span><br><span class="line">btnEle.onclick &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">var name &#x3D; nameEle.value;</span><br><span class="line">localstorage.setItem(&#39;name&#39;,name) &#x2F;&#x2F;(&#39;键&#39;,&#39;值&#39;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>页面二：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">window.onload &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">window.addEventListener(&#39;storage&#39;, (event)&#x3D;&gt;&#123;</span><br><span class="line">console.log(event.key,event.newValue)</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方法二——调用cookie-setInterval"><a href="#方法二——调用cookie-setInterval" class="headerlink" title="方法二——调用cookie+setInterval()"></a>方法二——调用cookie+setInterval()</h3><p>将要传递的信息储存再cookie中，每隔一段时间读取cookie信息，即可随时获得要传递的信息。</p><p>在A页面将需要传递的消息储存在cookie中</p><p>在B页面设置setInterval，以一定时间间隔去读取cookie的值</p><h5 id="页面一："><a href="#页面一：" class="headerlink" title="页面一："></a>页面一：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">window.onload &#x3D; function() &#123;</span><br><span class="line">var btnEle &#x3D; document.getElementById(&#39;btn&#39;);</span><br><span class="line">var iptEle &#x3D; document.getElementById(&#39;name&#39;);</span><br><span class="line">btnEle.onclick &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">var name &#x3D; iptEle.value;</span><br><span class="line">document.cookie &#x3D; &#39;name&#x3D;&#39;+name;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="页面二："><a href="#页面二：" class="headerlink" title="页面二："></a>页面二：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">window.onload &#x3D; function() &#123;</span><br><span class="line">function getCookie(key)&#123;</span><br><span class="line">console.log(document.cookie.replace(&#x2F;;\s+\gim,&#39;\&#39;,&#39;\&#39;).replace(&#x2F;&#x3D;&#x2F;gim,&#39;\&#39;:\&#39;&#39;));</span><br><span class="line">if(document.cookie) &#123;</span><br><span class="line">return JSON.parse(&#39;&#123;\&#39;&#39;+document.cookie.replace(&#x2F;;\s+\gim,&#39;\&#39;,&#39;\&#39;).replace(&#x2F;&#x3D;&#x2F;gim,&#39;\&#39;:\&#39;&#39;&#125;&#39;)</span><br><span class="line">&#125;else&#123;</span><br><span class="line">return &#39;&#39;;</span><br><span class="line">&#125;</span><br><span class="line">setInterval(function()&#123;</span><br><span class="line">console.log(&#39;name&#x3D;&#39;+getCookie(&#39;name&#39;))</span><br><span class="line">&#125;,5000)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="监听服务器事件"><a href="#监听服务器事件" class="headerlink" title="监听服务器事件"></a>监听服务器事件</h3><h4 id="第一种-websocket通讯"><a href="#第一种-websocket通讯" class="headerlink" title="第一种 websocket通讯"></a>第一种 websocket通讯</h4><p>websocket是全双工通信，可以实现多个标签页之间的通信。建立起websocket之后，服务器可以主动发数据给浏览器，浏览器也可以主动发数据给服务器。</p><p>http请求是半双工通讯，浏览器主动请求服务器发数据，服务器才能发数据，服务器不能主动给浏览器发数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;create websocket connection</span><br><span class="line">const socket &#x3D; new webSocket(&#39;ws:&#x2F;&#x2F;localhost:8080&#39;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;connection opened</span><br><span class="line">socket.addEventListener(&#39;open&#39;,function(event)&#123;</span><br><span class="line">socket.send(&#39;hello,server&#39;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;listen for message</span><br><span class="line">socket.addEventListener(&#39;message&#39;,function(event)&#123;</span><br><span class="line">console.log(event.data)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="第二种-html5新特性sharedWorker"><a href="#第二种-html5新特性sharedWorker" class="headerlink" title="第二种 html5新特性sharedWorker"></a>第二种 html5新特性sharedWorker</h4>]]></content>
    
    <summary type="html">
    
      fetch VS axios
    
    </summary>
    
    
      <category term="connection" scheme="http://yoursite.com/categories/connection/"/>
    
    
      <category term="locolStorage" scheme="http://yoursite.com/tags/locolStorage/"/>
    
      <category term="cookie" scheme="http://yoursite.com/tags/cookie/"/>
    
      <category term="webSocket" scheme="http://yoursite.com/tags/webSocket/"/>
    
  </entry>
  
  <entry>
    <title>02-fetch和axios的知识点总结</title>
    <link href="http://yoursite.com/2020/07/18/03-fetch%E5%92%8Caxios%E7%9A%84%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2020/07/18/03-fetch%E5%92%8Caxios%E7%9A%84%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/</id>
    <published>2020-07-18T06:45:34.000Z</published>
    <updated>2020-07-18T06:45:34.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h3 id="主要知识点："><a href="#主要知识点：" class="headerlink" title="主要知识点："></a>主要知识点：</h3><ol><li>fetch是规范底层API</li><li>axios是封装</li><li>fetch和axios的优缺点</li></ol><h2 id="fetch"><a href="#fetch" class="headerlink" title="fetch"></a>fetch</h2><p>fetch是一个低层次API，可以考虑成原生的XHR，使用起来并不是很方便，需要进行封装</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fetch(&#39;http:&#x2F;&#x2F;xxx.com&#x2F;xxx.json&#39;,第二个参数指定传输方式get、post)</span><br><span class="line">.then(res&#x3D;&gt;&#123;</span><br><span class="line">return res.json();</span><br><span class="line">&#125;).then(myJson&#x3D;&gt;&#123;</span><br><span class="line">console.log(myJson)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="fetch的优势（与XMLhttpRequset相比）"><a href="#fetch的优势（与XMLhttpRequset相比）" class="headerlink" title="fetch的优势（与XMLhttpRequset相比）"></a>fetch的优势（与XMLhttpRequset相比）</h4><ol><li>语法简洁，更加语义话</li><li>基于标准Promise实现，支持async/await</li><li>更加底层，提供的Api丰富（request，response）</li><li>脱离了XHR，是ES规范里新的实现方式</li></ol><h4 id="fetch的缺点"><a href="#fetch的缺点" class="headerlink" title="fetch的缺点"></a>fetch的缺点</h4><ol><li>fetch只对网络错误请求报错，400、500都当作成功的请求</li><li>fetch默认不会带cookie，需要添加配置项：fetch(url,{credentials:’include’})</li><li>fetch不支持abort终止请求</li><li>当上传较大的文件时，fetch不支持进度的监测，axios支持</li><li>fetch api需要手动处理返回的数据</li></ol><h2 id="axios"><a href="#axios" class="headerlink" title="axios"></a>axios</h2><p>axios是基于Promise用于浏览器和nodejs的HTTP客户端，本质上也是对原生XHR(XMLhttpRequest)的封装</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">axios.get(&#39;&#x2F;user&#39;,&#123;</span><br><span class="line">params:&#123;</span><br><span class="line">id:123</span><br><span class="line">&#125;</span><br><span class="line">&#125;).then(res &#x3D;&gt; &#123;</span><br><span class="line">console.log(res)</span><br><span class="line">&#125;).catch(err &#x3D;&gt; &#123;</span><br><span class="line">console.log(err)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="axios优点"><a href="#axios优点" class="headerlink" title="axios优点"></a>axios优点</h3><ol><li>从浏览器中创建XHR</li><li>支持PromiseAPI</li><li>客户端支持防止CSRF</li><li>提供一些并发请求的接口</li><li>从node.js创建http请求</li><li>拦截请求和响应</li><li>转换请求和响应数据</li><li>可以终止请求</li><li>自动转换json数据</li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>axios既提供了并发的封装，也没有fetch的各种问题，而且体积也较小，当之无愧现在最应该选用的请求的方法。</p><p>fetch vs axios</p><ol><li><p>fetch是底层的api 浏览器原生支持的；axios是一个封装好的框架</p></li><li><p>axios  支持浏览器和nodejs前后端发请求，支持promise语法，支持自动解析json，支持中断请求，支持拦截请求，支持请求进度条检测，支持客户端防止csrf</p></li><li><p>fetch的优点是浏览器原生支持的api，原生支持promise，语法简洁，符合es标准规范，缺点是不支持文件上传进度的检测，不支持终端请求，默认不带cookie，使用不完美，需要封装</p></li></ol>]]></content>
    
    <summary type="html">
    
      fetch VS axios
    
    </summary>
    
    
      <category term="XHR" scheme="http://yoursite.com/categories/XHR/"/>
    
    
      <category term="fetch" scheme="http://yoursite.com/tags/fetch/"/>
    
      <category term="axios" scheme="http://yoursite.com/tags/axios/"/>
    
  </entry>
  
  <entry>
    <title>01-Promise知识点整理</title>
    <link href="http://yoursite.com/2020/07/17/02-Promise%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/"/>
    <id>http://yoursite.com/2020/07/17/02-Promise%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/</id>
    <published>2020-07-17T11:37:00.000Z</published>
    <updated>2020-07-17T11:37:00.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h3 id="什么是地狱回调"><a href="#什么是地狱回调" class="headerlink" title="什么是地狱回调"></a>什么是地狱回调</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$.ajax(&#123;</span><br><span class="line">url:&quot;&#x2F;.php&#x2F;ok.php&quot;,</span><br><span class="line">success:res &#x3D;&gt; &#123;</span><br><span class="line">console.log(&#39;事件1&#39;,res)</span><br><span class="line">$.ajax(&#123;</span><br><span class="line">url:&quot;&#x2F;.php&#x2F;ok.php&quot;,</span><br><span class="line">success:res &#x3D;&gt; &#123;</span><br><span class="line">console.log(&#39;事件2&#39;,res)</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="什么是Promise"><a href="#什么是Promise" class="headerlink" title="什么是Promise"></a>什么是Promise</h3><p>promise是用于表示一个异步操作最终完成（失败）及其结果的对象,用于解决地狱回调</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">let p1 &#x3D; new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">    &#x2F;&#x2F;resolve 是成功的函数</span><br><span class="line">    &#x2F;&#x2F;reject 是失败的函数</span><br><span class="line">    resolve(1)</span><br><span class="line">&#125;).then(data &#x3D;&gt; &#123;</span><br><span class="line">    console.log(&#39;成功的函数&#39;, data); &#x2F;&#x2F;成功的函数 1</span><br><span class="line">    return new Promise(resolve &#x3D;&gt; &#123;</span><br><span class="line">        resolve(&#39;传递的数值&#39;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;).then(value &#x3D;&gt; &#123;</span><br><span class="line">    console.log(&#39;接收到&#39; + value);  &#x2F;&#x2F;接收到传递的数值</span><br><span class="line">&#125;).catch(err &#x3D;&gt; &#123;</span><br><span class="line">console.log(&#39;错误的函数&#39;+err)</span><br><span class="line">&#125;)&#x2F;&#x2F;最好不要在then方法里定义reject状态的回调函数，使用catch方法,会捕捉前面所有的错误</span><br></pre></td></tr></table></figure><h3 id="封装promise函数"><a href="#封装promise函数" class="headerlink" title="封装promise函数"></a>封装promise函数</h3><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/20/U4LDAK.png" alt=""></p><p>不停嵌套，地狱回调</p><h5 id="封装promise函数实现"><a href="#封装promise函数实现" class="headerlink" title="封装promise函数实现"></a>封装promise函数实现</h5><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/20/U4LfBt.png" alt=""></p><h3 id="promise链式调用"><a href="#promise链式调用" class="headerlink" title="promise链式调用"></a>promise链式调用</h3><h5 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class Tast1&#123;</span><br><span class="line">then() &#123;</span><br><span class="line">console.log(1);</span><br><span class="line">return this;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">var a &#x3D; new Tast1();</span><br><span class="line">a.then().then().then() &#x2F;&#x2F; 输出3次1</span><br></pre></td></tr></table></figure><h5 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class Test2&#123;</span><br><span class="line">then() &#123;</span><br><span class="line">console.log(2);</span><br><span class="line">        return new Test2()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">let b &#x3D; new Test2();</span><br><span class="line">b.then().then().then() &#x2F;&#x2F; 输出3次2</span><br></pre></td></tr></table></figure><h3 id="事件循环"><a href="#事件循环" class="headerlink" title="事件循环"></a>事件循环</h3><h5 id="同步与异步"><a href="#同步与异步" class="headerlink" title="同步与异步"></a>同步与异步</h5><p>同步：按照从上往下顺序执行，遇到需要等待的事件会停下来等待事件完成才继续往下执行；</p><p>异步：先按照从上往下顺序执行，遇到需要等待的事件将其加入异步队列，同步任务全部完成后去异步队列中先去出所有微任务执行，执行完毕后，取出第一个宏任务，当宏任务中所有相关的微任务执行完毕后，再执行下一个宏任务</p><ol><li>宏任务(macroTask) setTimeout、setInterval, requestAnimationFrame, I/O</li><li>微任务(microTask) process,nextTick,then,objcet.observe   </li></ol><p>例题：</p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/20/U4I2dg.png" alt=""></p><p>结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1.同步任务</span><br><span class="line">    3</span><br><span class="line">    7</span><br><span class="line">    4</span><br><span class="line">2.微任务</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3.宏任务</span><br><span class="line">5</span><br><span class="line">resolve只执行1次，所以6不输出</span><br></pre></td></tr></table></figure><h3 id="promise的方法"><a href="#promise的方法" class="headerlink" title="promise的方法"></a>promise的方法</h3><h5 id="promise的catch"><a href="#promise的catch" class="headerlink" title="promise的catch"></a>promise的catch</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">const someAsyncthing&#x3D;()&#x3D;&gt;&#123;</span><br><span class="line">return new Promise(function(res,rej)&#123;</span><br><span class="line">下面一行会报错，因为x未定义</span><br><span class="line">resolve(x+2)</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line">someAsyncthing().catch(error&#x3D;&gt;&#123;</span><br><span class="line">console.log(&#39;this is&#39;+error)</span><br><span class="line">&#125;).then(()&#x3D;&gt;console.log(&#39;carry on&#39;))</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;this is [ReferenceError: x is not defined]</span><br><span class="line">&#x2F;&#x2F;carry on </span><br><span class="line">上面代码运行完catch()方法指定的回调函数，会接着运行后面那个then()方法指定的回调函数。如果没有报错，则会跳过catch()方法。</span><br></pre></td></tr></table></figure><h5 id="promise的finally"><a href="#promise的finally" class="headerlink" title="promise的finally"></a>promise的finally</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">finally()方法用于指定不管 Promise 对象最后状态如何，都会执行的操作。</span><br><span class="line">&#x2F;&#x2F; resolve 的值是 undefined</span><br><span class="line">Promise.resolve(2).then(() &#x3D;&gt; &#123;&#125;, () &#x3D;&gt; &#123;&#125;)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; resolve 的值是 2</span><br><span class="line">Promise.resolve(2).finally(() &#x3D;&gt; &#123;&#125;)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; reject 的值是 undefined</span><br><span class="line">Promise.reject(3).then(() &#x3D;&gt; &#123;&#125;, () &#x3D;&gt; &#123;&#125;)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; reject 的值是 3</span><br><span class="line">Promise.reject(3).finally(() &#x3D;&gt; &#123;&#125;)</span><br><span class="line"></span><br><span class="line">finally方法总是会返回原来的值</span><br></pre></td></tr></table></figure><h5 id="Promise的all和race"><a href="#Promise的all和race" class="headerlink" title="Promise的all和race"></a>Promise的all和race</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">let p1 &#x3D; new Promise(function(resolve,reject)&#123;</span><br><span class="line">resolve(1)</span><br><span class="line">&#125;)</span><br><span class="line">&#x2F;&#x2F;promise.all(数组，第二个参数函数)</span><br><span class="line">Promise.all([p1,p2,p3...]).then().catch()</span><br><span class="line">&#x2F;&#x2F;Promise.all必须数组里所有的promise对象状态都为fulfilled，才执行then的回调函数，否则执行catch()</span><br><span class="line">Promise.race([p1,p2...]).then().catch()</span><br><span class="line">&#x2F;&#x2F;只要p1、p2、p3之中有一个实例率先改变状态，p的状态就跟着改变。那个率先改变的 Promise 实例的返回值，就传递给p的回调函数。</span><br></pre></td></tr></table></figure><h5 id="promise的allsettled"><a href="#promise的allsettled" class="headerlink" title="promise的allsettled"></a>promise的allsettled</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Promise.allSettled()方法接受一组 Promise 实例作为参数，包装成一个新的 Promise 实例。只有等到所有这些参数实例都返回结果，不管是fulfilled还是rejected，包装实例才会结束。</span><br><span class="line"></span><br><span class="line">const resolved &#x3D; Promise.resolve(42);</span><br><span class="line">const rejected &#x3D; Promise.reject(-1);</span><br><span class="line"></span><br><span class="line">const allSettledPromise &#x3D; Promise.allSettled([resolved, rejected]);</span><br><span class="line"></span><br><span class="line">allSettledPromise.then(function (results) &#123;</span><br><span class="line">  console.log(results);</span><br><span class="line">&#125;);</span><br><span class="line">&#x2F;&#x2F; [</span><br><span class="line">&#x2F;&#x2F;    &#123; status: &#39;fulfilled&#39;, value: 42 &#125;,</span><br><span class="line">&#x2F;&#x2F;    &#123; status: &#39;rejected&#39;, reason: -1 &#125;</span><br><span class="line">&#x2F;&#x2F; ]</span><br></pre></td></tr></table></figure><h5 id="promise的any"><a href="#promise的any" class="headerlink" title="promise的any"></a>promise的any</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">只要参数实例有一个变成fulfilled状态，包装实例就会变成fulfilled状态；如果所有参数实例都变成rejected状态，包装实例就会变成rejected状态。</span><br></pre></td></tr></table></figure><h5 id="promise的resolve"><a href="#promise的resolve" class="headerlink" title="promise的resolve"></a>promise的resolve</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Promise.resolve(&#39;foo&#39;)</span><br><span class="line">------等价于-------</span><br><span class="line">new Promise(resolve&#x3D;&gt;resolve(&#39;foo&#39;))</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      立下了每日更新博客的flag，今天是第一天~本篇是我对promise知识点的总结
    
    </summary>
    
    
      <category term="ES6" scheme="http://yoursite.com/categories/ES6/"/>
    
    
      <category term="Promise" scheme="http://yoursite.com/tags/Promise/"/>
    
  </entry>
  
  <entry>
    <title>如何给使用butterfly主题的hexo博客添加Valine评论功能</title>
    <link href="http://yoursite.com/2020/07/17/01-valineerr/"/>
    <id>http://yoursite.com/2020/07/17/01-valineerr/</id>
    <published>2020-07-17T10:07:00.000Z</published>
    <updated>2020-07-17T10:07:00.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Valine简介、方便、好用的评论系统</p><p>本文总结了如何在butterfly主题的hexo博客中添加Valine评论功能</p><p>附带一下午的踩坑经验</p><h2 id="开启Valine"><a href="#开启Valine" class="headerlink" title="开启Valine"></a>开启Valine</h2><h3 id="注册leancloud"><a href="#注册leancloud" class="headerlink" title="注册leancloud"></a>注册leancloud</h3><p><a href="https://www.leancloud.cn/" target="_blank" rel="noopener">leancloud注册官网</a></p><p>注册完以后需要创建一个应用，名字可以随便起，然后 进入应用-&gt;设置-&gt;应用key</p><p>获取你的appid 和 appkey 如图所示：</p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/19/UWuIzR.png" alt=""></p><p>拿到你的appid和appkey之后，打开butterfly.yml主题配置文件 搜索 valine，填入appid 和 appkey</p><p>我的配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">valine:</span><br><span class="line">  enable: true</span><br><span class="line">  appId: </span><br><span class="line">  appKey: </span><br><span class="line">  notify: false </span><br><span class="line">  verify: false </span><br><span class="line">  placeholder: 欢迎留言~</span><br><span class="line">  avatar: retro</span><br><span class="line">  guest_info: nick,mail,link </span><br><span class="line">  pageSize: 10 </span><br><span class="line">  ...</span><br></pre></td></tr></table></figure><p>到这儿还没有结束，不要忘记在butterfly.yml主题配置文件中添加comments配置，博主就是忘记配置comments踩坑了一个下午，查阅了好多网友的经验文章，终于找到为什么不显示的原因，加上以下语句就可以正常显示评论面板了。</p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/19/UWKHpj.png" alt=""></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://blog.csdn.net/blue_zy/article/details/79071414" target="_blank" rel="noopener">为你的Hexo加上评论系统-Valine</a></p><p><a href="https://valine.js.org/avatar.html" target="_blank" rel="noopener">valine官方文档</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="Hexo" scheme="http://yoursite.com/categories/Hexo/"/>
    
    
      <category term="Valine" scheme="http://yoursite.com/tags/Valine/"/>
    
  </entry>
  
</feed>
