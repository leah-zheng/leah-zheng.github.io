<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Leah&#39;s blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-07-23T13:28:42.223Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Leah Zheng</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>输出下面代码运行结果</title>
    <link href="http://yoursite.com/2020/07/23/10-%E8%BE%93%E5%87%BA%E4%B8%8B%E9%9D%A2%E4%BB%A3%E7%A0%81%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C/"/>
    <id>http://yoursite.com/2020/07/23/10-%E8%BE%93%E5%87%BA%E4%B8%8B%E9%9D%A2%E4%BB%A3%E7%A0%81%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C/</id>
    <published>2020-07-23T11:35:23.000Z</published>
    <updated>2020-07-23T13:28:42.223Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>输出下面代码运行结果</p><p>example 1</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var a &#x3D; &#123;&#125;，b&#x3D;&#39;123&#39;,c&#x3D;123;</span><br><span class="line">a[b]&#x3D;&#39;b&#39;;</span><br><span class="line">a[c]&#x3D;&#39;c&#39;;</span><br><span class="line">console.log(a[b]);</span><br></pre></td></tr></table></figure><p>example 2</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var a &#x3D; &#123;&#125;，b&#x3D;Symbol(&#39;123&#39;),c&#x3D;Symbol(&#39;123&#39;);</span><br><span class="line">a[b]&#x3D;&#39;b&#39;;</span><br><span class="line">a[c]&#x3D;&#39;c&#39;;</span><br><span class="line">console.log(a[b]);</span><br></pre></td></tr></table></figure><p>example 3</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var a &#x3D; &#123;&#125;，b&#x3D;&#123;key:&#39;123&#39;&#125;,c&#x3D;&#123;key:&#39;456&#39;&#125;;</span><br><span class="line">a[b]&#x3D;&#39;b&#39;;</span><br><span class="line">a[c]&#x3D;&#39;c&#39;;</span><br><span class="line">console.log(a[b]);</span><br></pre></td></tr></table></figure><p>答案：</p><ol><li><p>c  =&gt; 因为a[‘123’] == a[123]</p></li><li><p>b  =&gt;Symbol是ES6中新增的数据类型，typeof Smybol(‘123’) === Smybol,它创建出的值是唯一的</p><p>Smybol(‘123’) =！Smybol(‘123’) </p></li><li><p>c =&gt;  对象的属性名不能是一个对象，若是对象属性名，会默认转换为字符串</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">obj&#x3D;&#123;&#125; arr&#x3D;[11,22] obj[arr]&#x3D;33  obj&#x3D;&gt;&#123;&#39;11,22&#39;:33&#125;</span><br></pre></td></tr></table></figure><p>普通对象.toString() 调取的是Object.prototype上的方法(这个方法是用来检测数据类型的)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">obj&#x3D;&#123;&#125; obj.toString()&#x3D;&gt;&#39;[Object Object]&#39;</span><br><span class="line">obj[b]&#x3D;&#39;b&#39; &#x3D;&gt; obj[&#39;[Object Object]&#39;]&#x3D;&#39;b&#39;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
    
      <category term="Symbol" scheme="http://yoursite.com/tags/Symbol/"/>
    
      <category term="prototype" scheme="http://yoursite.com/tags/prototype/"/>
    
  </entry>
  
  <entry>
    <title>实现(5).add(3).minus(2)，使其结果为6</title>
    <link href="http://yoursite.com/2020/07/22/07-%E5%AE%9E%E7%8E%B0(5).add(3).minus(2)/"/>
    <id>http://yoursite.com/2020/07/22/07-%E5%AE%9E%E7%8E%B0(5).add(3).minus(2)/</id>
    <published>2020-07-22T12:35:23.000Z</published>
    <updated>2020-07-22T12:31:37.222Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">~function()&#123;</span><br><span class="line">&#x2F;&#x2F;每一个方法执行完，都要返回Number这个类的实例，这样才可以继续调取Number类原型中的方法</span><br><span class="line">function check(n)&#123;</span><br><span class="line">n &#x3D; Nunber(n);</span><br><span class="line">return isNaN(n)?0:n;</span><br><span class="line">&#125;</span><br><span class="line">function add(n)&#123;</span><br><span class="line">n &#x3D; check(n);</span><br><span class="line">return this+n;</span><br><span class="line">&#125;</span><br><span class="line">functino minus(n)&#123;</span><br><span class="line">n &#x3D; check(n);</span><br><span class="line">return this-n;</span><br><span class="line">&#125;</span><br><span class="line">Number.prototype.add &#x3D; add;</span><br><span class="line">Number.prototype.minus &#x3D; minus;</span><br><span class="line">&#x2F;*[add,minus].foreach(item&#x3D;&gt;&#123;</span><br><span class="line">Number.prototype[item]&#x3D;eval(item)</span><br><span class="line">&#125;)*&#x2F;</span><br><span class="line">&#125;();</span><br><span class="line">(5).add(3).minus(2)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="JS算法" scheme="http://yoursite.com/categories/JS%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="JS算法" scheme="http://yoursite.com/tags/JS%E7%AE%97%E6%B3%95/"/>
    
      <category term="prototype" scheme="http://yoursite.com/tags/prototype/"/>
    
  </entry>
  
  <entry>
    <title>如何把一个字符串的大小写取反</title>
    <link href="http://yoursite.com/2020/07/22/06-%E5%A6%82%E4%BD%95%E6%8A%8A%E4%B8%80%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%A4%A7%E5%B0%8F%E5%86%99%E5%8F%96%E5%8F%8D/"/>
    <id>http://yoursite.com/2020/07/22/06-%E5%A6%82%E4%BD%95%E6%8A%8A%E4%B8%80%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%A4%A7%E5%B0%8F%E5%86%99%E5%8F%96%E5%8F%8D/</id>
    <published>2020-07-22T12:28:08.000Z</published>
    <updated>2020-07-22T12:28:54.683Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="如何把一个字符串的大小写取反（大写变小写，小写变大写）"><a href="#如何把一个字符串的大小写取反（大写变小写，小写变大写）" class="headerlink" title="如何把一个字符串的大小写取反（大写变小写，小写变大写）"></a>如何把一个字符串的大小写取反（大写变小写，小写变大写）</h2><h4 id=""><a href="#" class="headerlink" title=""></a></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let str &#x3D; &#39;hfubH就U观看dhHUd耳机的H日e就&#39;</span><br><span class="line">&#x2F;&#x2F; content:每次正则匹配的结果</span><br><span class="line">&#x2F;&#x2F;把字母转换为大写后判断是否和之前一样，若一样则要转小写</span><br><span class="line">&#x2F;&#x2F;或者在ASCII表中找大写字母的取值范围(65-90)进行判断charCodeAt</span><br><span class="line">str.replace(&#x2F;[a-zA-Z]&#x2F;g,content&#x3D;&gt;&#123;</span><br><span class="line">return content.toUpperCase() &#x3D;&#x3D;&#x3D; content? content.toLowerCase() : content.toUpperCase();</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="JS算法" scheme="http://yoursite.com/categories/JS%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="JS算法" scheme="http://yoursite.com/tags/JS%E7%AE%97%E6%B3%95/"/>
    
      <category term="字符串" scheme="http://yoursite.com/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>实现一个字符串匹配算法</title>
    <link href="http://yoursite.com/2020/07/22/05-%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95/"/>
    <id>http://yoursite.com/2020/07/22/05-%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95/</id>
    <published>2020-07-22T12:23:08.000Z</published>
    <updated>2020-07-22T12:26:45.666Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="从字符串S中，查找是否存在字符串T，若存在返回所在位置，不存在返回-1（不能基于indexOf-includes等内置方法）"><a href="#从字符串S中，查找是否存在字符串T，若存在返回所在位置，不存在返回-1（不能基于indexOf-includes等内置方法）" class="headerlink" title="从字符串S中，查找是否存在字符串T，若存在返回所在位置，不存在返回-1（不能基于indexOf/includes等内置方法）"></a>从字符串S中，查找是否存在字符串T，若存在返回所在位置，不存在返回-1（不能基于indexOf/includes等内置方法）</h2><h4 id=""><a href="#" class="headerlink" title=""></a></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">~function()&#123;</span><br><span class="line">&#x2F;&#x2F;方法一 循环遍历</span><br><span class="line">&#x2F;*function myIndexOf(T) &#123;</span><br><span class="line">let lenS &#x3D; S.length,</span><br><span class="line">lenT &#x3D; T.length,</span><br><span class="line">res &#x3D; -1;</span><br><span class="line">if (lenT&gt;lenS) return -1;</span><br><span class="line">for(let i&#x3D;0;i&lt;&#x3D;lenS - lenT + 1;i++) &#123;</span><br><span class="line">if(this.substr(i,lenT) &#x3D;&#x3D;&#x3D; T) &#123;</span><br><span class="line">res &#x3D; i;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">return res;</span><br><span class="line">&#125;*&#x2F;</span><br><span class="line"></span><br><span class="line">--------------------------------------------</span><br><span class="line">    </span><br><span class="line">方法二 正则匹配</span><br><span class="line">&#x2F;*function myIndexOf(T)&#123;</span><br><span class="line">let reg &#x3D; new RegExp(T),</span><br><span class="line">res &#x3D; reg.exec(this);</span><br><span class="line">return res&#x3D;&#x3D;&#x3D;null ? -1：res.index; </span><br><span class="line">&#125;*&#x2F;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">String.prototype.myIndexOf &#x3D; myIndexOf();</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line">let S &#x3D; &#39;doujingtongmeme&#39;,</span><br><span class="line">T &#x3D; &#39;to&#39;;</span><br><span class="line">console.log(S.myIndexOf(T))</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="JS算法" scheme="http://yoursite.com/categories/JS%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="JS算法" scheme="http://yoursite.com/tags/JS%E7%AE%97%E6%B3%95/"/>
    
      <category term="字符串" scheme="http://yoursite.com/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>05-call和apply的区别是什么，哪个性能更好一些？</title>
    <link href="http://yoursite.com/2020/07/21/08-call%E5%92%8Capply%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88/"/>
    <id>http://yoursite.com/2020/07/21/08-call%E5%92%8Capply%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88/</id>
    <published>2020-07-21T12:55:23.000Z</published>
    <updated>2020-07-22T12:55:56.461Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>call和apply都是<strong>Function原型上</strong>的方法，而每个函数作为Function这个类的<strong>实例</strong>，可以调用原型上的call和apply方法。<br>call和apply都是用来改变this指向的，区别是call是传递参数时是<strong>一个一个传参</strong>，而apply要求把参数<strong>以数组的形式</strong>传递。<br>还有一个类似的方式bind()，bind也是改变this的指向，<strong>但没有立即执行函数</strong>，只是预先处理改变this指向。<br><strong>call的性能要比apply好一些</strong>，尤其是传递给函数的参数超过<strong>三个</strong>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let arr &#x3D; [1,2,3],</span><br><span class="line">obj &#x3D; &#123;&#125;;</span><br><span class="line">function fn(a,b,c) &#123;&#125;;</span><br><span class="line">fn.apply(obj,arr) &#x2F;&#x2F;a&#x3D;1,b&#x3D;2,c&#x3D;3</span><br><span class="line">fn.call(obj,arr) &#x2F;&#x2F;a&#x3D;[1,2,3] b&#x3D;c&#x3D;undefined</span><br><span class="line">fn.call(obj,..arr) &#x2F;&#x2F;基于es6的展开运算符能够实现把数组中的每一项一次传递给函数</span><br></pre></td></tr></table></figure><h4 id="补充："><a href="#补充：" class="headerlink" title="补充："></a>补充：</h4><h4 id="自己实现性能测试（只供参考）"><a href="#自己实现性能测试（只供参考）" class="headerlink" title="自己实现性能测试（只供参考）"></a>自己实现性能测试（只供参考）</h4><p>任何代码性能测试都是和测试环境有关的，例如CPU、内存、GPU等电脑当前性能不会有相同的情况，不同浏览器也会导致性能的不同。</p><h5 id="console-time可以测试出一段程序执行的时间"><a href="#console-time可以测试出一段程序执行的时间" class="headerlink" title="console.time可以测试出一段程序执行的时间"></a>console.time可以测试出一段程序执行的时间</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">console.time(&#39;a&#39;);</span><br><span class="line">for(let i&#x3D;0;i&lt;1000000000;i++) &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">console.timeEnd(&#39;a&#39;)</span><br></pre></td></tr></table></figure><p>console.profile()在火狐浏览器中安装fireBug,可以更精准的获取到程序的每一个步骤所消耗的时间</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="this" scheme="http://yoursite.com/categories/this/"/>
    
    
      <category term="this" scheme="http://yoursite.com/tags/this/"/>
    
  </entry>
  
  <entry>
    <title>04-箭头函数与普通函数的区别？</title>
    <link href="http://yoursite.com/2020/07/20/09-%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%E4%B8%8E%E6%99%AE%E9%80%9A%E5%87%BD%E6%95%B0%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://yoursite.com/2020/07/20/09-%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%E4%B8%8E%E6%99%AE%E9%80%9A%E5%87%BD%E6%95%B0%E7%9A%84%E5%8C%BA%E5%88%AB/</id>
    <published>2020-07-20T07:23:42.000Z</published>
    <updated>2020-07-22T12:46:12.353Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="箭头函数与普通函数的区别？构造函数可以使用new生成实例，那么箭头函数可以吗？为什么？"><a href="#箭头函数与普通函数的区别？构造函数可以使用new生成实例，那么箭头函数可以吗？为什么？" class="headerlink" title="箭头函数与普通函数的区别？构造函数可以使用new生成实例，那么箭头函数可以吗？为什么？"></a>箭头函数与普通函数的区别？构造函数可以使用new生成实例，那么箭头函数可以吗？为什么？</h2><h4 id="箭头函数与普通函数的区别："><a href="#箭头函数与普通函数的区别：" class="headerlink" title="箭头函数与普通函数的区别："></a>箭头函数与普通函数的区别：</h4><ol><li><p>箭头函数语法比普通函数更加简洁（ES6中每一种函数都可以使用形参赋默认值(x=0)和剩余运算符(…arg)）</p></li><li><p>箭头函数没有自己的this，它里面的this是继承函数所处上下文中的this（使用call/apply等任何方式都无法改变指向）</p></li><li><p>箭头函数中没有argument（类数组），只能基于…arg获取传递的参数集合（数组）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function fn(...arg) &#123;</span><br><span class="line">console.log(arg)</span><br><span class="line">&#125;</span><br><span class="line">fn(1,2,3) &#x2F;&#x2F; [1,2,3]</span><br><span class="line">-------------------------</span><br><span class="line">function add(...arg) &#123;</span><br><span class="line">return arg.reduce((m,n)&#x3D;&gt;m+n,0)</span><br><span class="line">&#125;</span><br><span class="line">add(1,2,3) &#x2F;&#x2F; 6</span><br></pre></td></tr></table></figure></li><li><p>箭头函数不能被new执行（因为箭头函数没有prototype也没有this）</p></li></ol><h4 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h4><p>把一个函数A作为实参传递给另一个函数B，函数B在执行的时候，可以把传递进来的函数A去执行（执行N次，可传值，可改this ）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function each(arr,callback) &#123;</span><br><span class="line">for(let i&#x3D;0;i&lt;arr.length;i++) &#123;</span><br><span class="line">let flag &#x3D; callback.call(arr,i,arr[i])</span><br><span class="line">if (flag &#x3D;&#x3D;&#x3D; false)&#123;</span><br><span class="line">break</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">each([10,20,30],function(index,item)&#123;</span><br><span class="line">if(index &gt;1) &#123;</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="ES6" scheme="http://yoursite.com/categories/ES6/"/>
    
    
      <category term="ES6" scheme="http://yoursite.com/tags/ES6/"/>
    
  </entry>
  
  <entry>
    <title>03-实现浏览器内多个标签页之间的通讯</title>
    <link href="http://yoursite.com/2020/07/19/04-%E6%B5%8F%E8%A7%88%E5%99%A8%E5%86%85%E5%A4%9A%E4%B8%AA%E6%A0%87%E7%AD%BE%E9%A1%B5%E4%B9%8B%E9%97%B4%E7%9A%84%E9%80%9A%E8%AE%AF/"/>
    <id>http://yoursite.com/2020/07/19/04-%E6%B5%8F%E8%A7%88%E5%99%A8%E5%86%85%E5%A4%9A%E4%B8%AA%E6%A0%87%E7%AD%BE%E9%A1%B5%E4%B9%8B%E9%97%B4%E7%9A%84%E9%80%9A%E8%AE%AF/</id>
    <published>2020-07-19T04:23:41.000Z</published>
    <updated>2020-07-20T04:23:41.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>实现多页通讯主要有利用浏览器储存和服务器方式</p><h3 id="知识考察点"><a href="#知识考察点" class="headerlink" title="知识考察点"></a>知识考察点</h3><p>什么是多页应用</p><p>两种浏览器存储方式实现多页间通讯</p><p>websoket和shareworker实现多页通讯</p><h3 id="方法一——调用localstorage"><a href="#方法一——调用localstorage" class="headerlink" title="方法一——调用localstorage"></a>方法一——调用localstorage</h3><p>页面一：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">window.onload &#x3D; ()&#x3D;&gt;&#123;</span><br><span class="line">var btnEle &#x3D; document.getElementById(&#39;btn&#39;);</span><br><span class="line">var nameEle &#x3D; document.getElementById(&#39;name&#39;);</span><br><span class="line">btnEle.onclick &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">var name &#x3D; nameEle.value;</span><br><span class="line">localstorage.setItem(&#39;name&#39;,name) &#x2F;&#x2F;(&#39;键&#39;,&#39;值&#39;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>页面二：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">window.onload &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">window.addEventListener(&#39;storage&#39;, (event)&#x3D;&gt;&#123;</span><br><span class="line">console.log(event.key,event.newValue)</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方法二——调用cookie-setInterval"><a href="#方法二——调用cookie-setInterval" class="headerlink" title="方法二——调用cookie+setInterval()"></a>方法二——调用cookie+setInterval()</h3><p>将要传递的信息储存再cookie中，每隔一段时间读取cookie信息，即可随时获得要传递的信息。</p><p>在A页面将需要传递的消息储存在cookie中</p><p>在B页面设置setInterval，以一定时间间隔去读取cookie的值</p><h5 id="页面一："><a href="#页面一：" class="headerlink" title="页面一："></a>页面一：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">window.onload &#x3D; function() &#123;</span><br><span class="line">var btnEle &#x3D; document.getElementById(&#39;btn&#39;);</span><br><span class="line">var iptEle &#x3D; document.getElementById(&#39;name&#39;);</span><br><span class="line">btnEle.onclick &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">var name &#x3D; iptEle.value;</span><br><span class="line">document.cookie &#x3D; &#39;name&#x3D;&#39;+name;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="页面二："><a href="#页面二：" class="headerlink" title="页面二："></a>页面二：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">window.onload &#x3D; function() &#123;</span><br><span class="line">function getCookie(key)&#123;</span><br><span class="line">console.log(document.cookie.replace(&#x2F;;\s+\gim,&#39;\&#39;,&#39;\&#39;).replace(&#x2F;&#x3D;&#x2F;gim,&#39;\&#39;:\&#39;&#39;));</span><br><span class="line">if(document.cookie) &#123;</span><br><span class="line">return JSON.parse(&#39;&#123;\&#39;&#39;+document.cookie.replace(&#x2F;;\s+\gim,&#39;\&#39;,&#39;\&#39;).replace(&#x2F;&#x3D;&#x2F;gim,&#39;\&#39;:\&#39;&#39;&#125;&#39;)</span><br><span class="line">&#125;else&#123;</span><br><span class="line">return &#39;&#39;;</span><br><span class="line">&#125;</span><br><span class="line">setInterval(function()&#123;</span><br><span class="line">console.log(&#39;name&#x3D;&#39;+getCookie(&#39;name&#39;))</span><br><span class="line">&#125;,5000)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="监听服务器事件"><a href="#监听服务器事件" class="headerlink" title="监听服务器事件"></a>监听服务器事件</h3><h4 id="第一种-websocket通讯"><a href="#第一种-websocket通讯" class="headerlink" title="第一种 websocket通讯"></a>第一种 websocket通讯</h4><p>websocket是全双工通信，可以实现多个标签页之间的通信。建立起websocket之后，服务器可以主动发数据给浏览器，浏览器也可以主动发数据给服务器。</p><p>http请求是半双工通讯，浏览器主动请求服务器发数据，服务器才能发数据，服务器不能主动给浏览器发数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;create websocket connection</span><br><span class="line">const socket &#x3D; new webSocket(&#39;ws:&#x2F;&#x2F;localhost:8080&#39;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;connection opened</span><br><span class="line">socket.addEventListener(&#39;open&#39;,function(event)&#123;</span><br><span class="line">socket.send(&#39;hello,server&#39;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;listen for message</span><br><span class="line">socket.addEventListener(&#39;message&#39;,function(event)&#123;</span><br><span class="line">console.log(event.data)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="第二种-html5新特性sharedWorker"><a href="#第二种-html5新特性sharedWorker" class="headerlink" title="第二种 html5新特性sharedWorker"></a>第二种 html5新特性sharedWorker</h4>]]></content>
    
    <summary type="html">
    
      fetch VS axios
    
    </summary>
    
    
      <category term="connection" scheme="http://yoursite.com/categories/connection/"/>
    
    
      <category term="locolStorage" scheme="http://yoursite.com/tags/locolStorage/"/>
    
      <category term="cookie" scheme="http://yoursite.com/tags/cookie/"/>
    
      <category term="webSocket" scheme="http://yoursite.com/tags/webSocket/"/>
    
  </entry>
  
  <entry>
    <title>02-fetch和axios的知识点总结</title>
    <link href="http://yoursite.com/2020/07/18/03-fetch%E5%92%8Caxios%E7%9A%84%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2020/07/18/03-fetch%E5%92%8Caxios%E7%9A%84%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/</id>
    <published>2020-07-18T06:45:34.000Z</published>
    <updated>2020-07-18T06:45:34.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h3 id="主要知识点："><a href="#主要知识点：" class="headerlink" title="主要知识点："></a>主要知识点：</h3><ol><li>fetch是规范底层API</li><li>axios是封装</li><li>fetch和axios的优缺点</li></ol><h2 id="fetch"><a href="#fetch" class="headerlink" title="fetch"></a>fetch</h2><p>fetch是一个低层次API，可以考虑成原生的XHR，使用起来并不是很方便，需要进行封装</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fetch(&#39;http:&#x2F;&#x2F;xxx.com&#x2F;xxx.json&#39;,第二个参数指定传输方式get、post)</span><br><span class="line">.then(res&#x3D;&gt;&#123;</span><br><span class="line">return res.json();</span><br><span class="line">&#125;).then(myJson&#x3D;&gt;&#123;</span><br><span class="line">console.log(myJson)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="fetch的优势（与XMLhttpRequset相比）"><a href="#fetch的优势（与XMLhttpRequset相比）" class="headerlink" title="fetch的优势（与XMLhttpRequset相比）"></a>fetch的优势（与XMLhttpRequset相比）</h4><ol><li>语法简洁，更加语义话</li><li>基于标准Promise实现，支持async/await</li><li>更加底层，提供的Api丰富（request，response）</li><li>脱离了XHR，是ES规范里新的实现方式</li></ol><h4 id="fetch的缺点"><a href="#fetch的缺点" class="headerlink" title="fetch的缺点"></a>fetch的缺点</h4><ol><li>fetch只对网络错误请求报错，400、500都当作成功的请求</li><li>fetch默认不会带cookie，需要添加配置项：fetch(url,{credentials:’include’})</li><li>fetch不支持abort终止请求</li><li>当上传较大的文件时，fetch不支持进度的监测，axios支持</li><li>fetch api需要手动处理返回的数据</li></ol><h2 id="axios"><a href="#axios" class="headerlink" title="axios"></a>axios</h2><p>axios是基于Promise用于浏览器和nodejs的HTTP客户端，本质上也是对原生XHR(XMLhttpRequest)的封装</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">axios.get(&#39;&#x2F;user&#39;,&#123;</span><br><span class="line">params:&#123;</span><br><span class="line">id:123</span><br><span class="line">&#125;</span><br><span class="line">&#125;).then(res &#x3D;&gt; &#123;</span><br><span class="line">console.log(res)</span><br><span class="line">&#125;).catch(err &#x3D;&gt; &#123;</span><br><span class="line">console.log(err)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="axios优点"><a href="#axios优点" class="headerlink" title="axios优点"></a>axios优点</h3><ol><li>从浏览器中创建XHR</li><li>支持PromiseAPI</li><li>客户端支持防止CSRF</li><li>提供一些并发请求的接口</li><li>从node.js创建http请求</li><li>拦截请求和响应</li><li>转换请求和响应数据</li><li>可以终止请求</li><li>自动转换json数据</li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>axios既提供了并发的封装，也没有fetch的各种问题，而且体积也较小，当之无愧现在最应该选用的请求的方法。</p><p>fetch vs axios</p><ol><li><p>fetch是底层的api 浏览器原生支持的；axios是一个封装好的框架</p></li><li><p>axios  支持浏览器和nodejs前后端发请求，支持promise语法，支持自动解析json，支持中断请求，支持拦截请求，支持请求进度条检测，支持客户端防止csrf</p></li><li><p>fetch的优点是浏览器原生支持的api，原生支持promise，语法简洁，符合es标准规范，缺点是不支持文件上传进度的检测，不支持终端请求，默认不带cookie，使用不完美，需要封装</p></li></ol>]]></content>
    
    <summary type="html">
    
      fetch VS axios
    
    </summary>
    
    
      <category term="XHR" scheme="http://yoursite.com/categories/XHR/"/>
    
    
      <category term="fetch" scheme="http://yoursite.com/tags/fetch/"/>
    
      <category term="axios" scheme="http://yoursite.com/tags/axios/"/>
    
  </entry>
  
  <entry>
    <title>01-Promise知识点整理</title>
    <link href="http://yoursite.com/2020/07/17/02-Promise%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/"/>
    <id>http://yoursite.com/2020/07/17/02-Promise%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/</id>
    <published>2020-07-17T11:37:00.000Z</published>
    <updated>2020-07-17T11:37:00.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h3 id="什么是地狱回调"><a href="#什么是地狱回调" class="headerlink" title="什么是地狱回调"></a>什么是地狱回调</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$.ajax(&#123;</span><br><span class="line">url:&quot;&#x2F;.php&#x2F;ok.php&quot;,</span><br><span class="line">success:res &#x3D;&gt; &#123;</span><br><span class="line">console.log(&#39;事件1&#39;,res)</span><br><span class="line">$.ajax(&#123;</span><br><span class="line">url:&quot;&#x2F;.php&#x2F;ok.php&quot;,</span><br><span class="line">success:res &#x3D;&gt; &#123;</span><br><span class="line">console.log(&#39;事件2&#39;,res)</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="什么是Promise"><a href="#什么是Promise" class="headerlink" title="什么是Promise"></a>什么是Promise</h3><p>promise是用于表示一个异步操作最终完成（失败）及其结果的对象,用于解决地狱回调</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">let p1 &#x3D; new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">    &#x2F;&#x2F;resolve 是成功的函数</span><br><span class="line">    &#x2F;&#x2F;reject 是失败的函数</span><br><span class="line">    resolve(1)</span><br><span class="line">&#125;).then(data &#x3D;&gt; &#123;</span><br><span class="line">    console.log(&#39;成功的函数&#39;, data); &#x2F;&#x2F;成功的函数 1</span><br><span class="line">    return new Promise(resolve &#x3D;&gt; &#123;</span><br><span class="line">        resolve(&#39;传递的数值&#39;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;).then(value &#x3D;&gt; &#123;</span><br><span class="line">    console.log(&#39;接收到&#39; + value);  &#x2F;&#x2F;接收到传递的数值</span><br><span class="line">&#125;).catch(err &#x3D;&gt; &#123;</span><br><span class="line">console.log(&#39;错误的函数&#39;+err)</span><br><span class="line">&#125;)&#x2F;&#x2F;最好不要在then方法里定义reject状态的回调函数，使用catch方法,会捕捉前面所有的错误</span><br></pre></td></tr></table></figure><h3 id="封装promise函数"><a href="#封装promise函数" class="headerlink" title="封装promise函数"></a>封装promise函数</h3><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/20/U4LDAK.png" alt=""></p><p>不停嵌套，地狱回调</p><h5 id="封装promise函数实现"><a href="#封装promise函数实现" class="headerlink" title="封装promise函数实现"></a>封装promise函数实现</h5><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/20/U4LfBt.png" alt=""></p><h3 id="promise链式调用"><a href="#promise链式调用" class="headerlink" title="promise链式调用"></a>promise链式调用</h3><h5 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class Tast1&#123;</span><br><span class="line">then() &#123;</span><br><span class="line">console.log(1);</span><br><span class="line">return this;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">var a &#x3D; new Tast1();</span><br><span class="line">a.then().then().then() &#x2F;&#x2F; 输出3次1</span><br></pre></td></tr></table></figure><h5 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class Test2&#123;</span><br><span class="line">then() &#123;</span><br><span class="line">console.log(2);</span><br><span class="line">        return new Test2()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">let b &#x3D; new Test2();</span><br><span class="line">b.then().then().then() &#x2F;&#x2F; 输出3次2</span><br></pre></td></tr></table></figure><h3 id="事件循环"><a href="#事件循环" class="headerlink" title="事件循环"></a>事件循环</h3><h5 id="同步与异步"><a href="#同步与异步" class="headerlink" title="同步与异步"></a>同步与异步</h5><p>同步：按照从上往下顺序执行，遇到需要等待的事件会停下来等待事件完成才继续往下执行；</p><p>异步：先按照从上往下顺序执行，遇到需要等待的事件将其加入异步队列，同步任务全部完成后去异步队列中先去出所有微任务执行，执行完毕后，取出第一个宏任务，当宏任务中所有相关的微任务执行完毕后，再执行下一个宏任务</p><ol><li>宏任务(macroTask) setTimeout、setInterval, requestAnimationFrame, I/O</li><li>微任务(microTask) process,nextTick,then,objcet.observe   </li></ol><p>例题：</p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/20/U4I2dg.png" alt=""></p><p>结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1.同步任务</span><br><span class="line">    3</span><br><span class="line">    7</span><br><span class="line">    4</span><br><span class="line">2.微任务</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3.宏任务</span><br><span class="line">5</span><br><span class="line">resolve只执行1次，所以6不输出</span><br></pre></td></tr></table></figure><h3 id="promise的方法"><a href="#promise的方法" class="headerlink" title="promise的方法"></a>promise的方法</h3><h5 id="promise的catch"><a href="#promise的catch" class="headerlink" title="promise的catch"></a>promise的catch</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">const someAsyncthing&#x3D;()&#x3D;&gt;&#123;</span><br><span class="line">return new Promise(function(res,rej)&#123;</span><br><span class="line">下面一行会报错，因为x未定义</span><br><span class="line">resolve(x+2)</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line">someAsyncthing().catch(error&#x3D;&gt;&#123;</span><br><span class="line">console.log(&#39;this is&#39;+error)</span><br><span class="line">&#125;).then(()&#x3D;&gt;console.log(&#39;carry on&#39;))</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;this is [ReferenceError: x is not defined]</span><br><span class="line">&#x2F;&#x2F;carry on </span><br><span class="line">上面代码运行完catch()方法指定的回调函数，会接着运行后面那个then()方法指定的回调函数。如果没有报错，则会跳过catch()方法。</span><br></pre></td></tr></table></figure><h5 id="promise的finally"><a href="#promise的finally" class="headerlink" title="promise的finally"></a>promise的finally</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">finally()方法用于指定不管 Promise 对象最后状态如何，都会执行的操作。</span><br><span class="line">&#x2F;&#x2F; resolve 的值是 undefined</span><br><span class="line">Promise.resolve(2).then(() &#x3D;&gt; &#123;&#125;, () &#x3D;&gt; &#123;&#125;)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; resolve 的值是 2</span><br><span class="line">Promise.resolve(2).finally(() &#x3D;&gt; &#123;&#125;)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; reject 的值是 undefined</span><br><span class="line">Promise.reject(3).then(() &#x3D;&gt; &#123;&#125;, () &#x3D;&gt; &#123;&#125;)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; reject 的值是 3</span><br><span class="line">Promise.reject(3).finally(() &#x3D;&gt; &#123;&#125;)</span><br><span class="line"></span><br><span class="line">finally方法总是会返回原来的值</span><br></pre></td></tr></table></figure><h5 id="Promise的all和race"><a href="#Promise的all和race" class="headerlink" title="Promise的all和race"></a>Promise的all和race</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">let p1 &#x3D; new Promise(function(resolve,reject)&#123;</span><br><span class="line">resolve(1)</span><br><span class="line">&#125;)</span><br><span class="line">&#x2F;&#x2F;promise.all(数组，第二个参数函数)</span><br><span class="line">Promise.all([p1,p2,p3...]).then().catch()</span><br><span class="line">&#x2F;&#x2F;Promise.all必须数组里所有的promise对象状态都为fulfilled，才执行then的回调函数，否则执行catch()</span><br><span class="line">Promise.race([p1,p2...]).then().catch()</span><br><span class="line">&#x2F;&#x2F;只要p1、p2、p3之中有一个实例率先改变状态，p的状态就跟着改变。那个率先改变的 Promise 实例的返回值，就传递给p的回调函数。</span><br></pre></td></tr></table></figure><h5 id="promise的allsettled"><a href="#promise的allsettled" class="headerlink" title="promise的allsettled"></a>promise的allsettled</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Promise.allSettled()方法接受一组 Promise 实例作为参数，包装成一个新的 Promise 实例。只有等到所有这些参数实例都返回结果，不管是fulfilled还是rejected，包装实例才会结束。</span><br><span class="line"></span><br><span class="line">const resolved &#x3D; Promise.resolve(42);</span><br><span class="line">const rejected &#x3D; Promise.reject(-1);</span><br><span class="line"></span><br><span class="line">const allSettledPromise &#x3D; Promise.allSettled([resolved, rejected]);</span><br><span class="line"></span><br><span class="line">allSettledPromise.then(function (results) &#123;</span><br><span class="line">  console.log(results);</span><br><span class="line">&#125;);</span><br><span class="line">&#x2F;&#x2F; [</span><br><span class="line">&#x2F;&#x2F;    &#123; status: &#39;fulfilled&#39;, value: 42 &#125;,</span><br><span class="line">&#x2F;&#x2F;    &#123; status: &#39;rejected&#39;, reason: -1 &#125;</span><br><span class="line">&#x2F;&#x2F; ]</span><br></pre></td></tr></table></figure><h5 id="promise的any"><a href="#promise的any" class="headerlink" title="promise的any"></a>promise的any</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">只要参数实例有一个变成fulfilled状态，包装实例就会变成fulfilled状态；如果所有参数实例都变成rejected状态，包装实例就会变成rejected状态。</span><br></pre></td></tr></table></figure><h5 id="promise的resolve"><a href="#promise的resolve" class="headerlink" title="promise的resolve"></a>promise的resolve</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Promise.resolve(&#39;foo&#39;)</span><br><span class="line">------等价于-------</span><br><span class="line">new Promise(resolve&#x3D;&gt;resolve(&#39;foo&#39;))</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      立下了每日更新博客的flag，今天是第一天~本篇是我对promise知识点的总结
    
    </summary>
    
    
      <category term="ES6" scheme="http://yoursite.com/categories/ES6/"/>
    
    
      <category term="Promise" scheme="http://yoursite.com/tags/Promise/"/>
    
  </entry>
  
  <entry>
    <title>如何给使用butterfly主题的hexo博客添加Valine评论功能</title>
    <link href="http://yoursite.com/2020/07/17/01-valineerr/"/>
    <id>http://yoursite.com/2020/07/17/01-valineerr/</id>
    <published>2020-07-17T10:07:00.000Z</published>
    <updated>2020-07-17T10:07:00.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Valine简介、方便、好用的评论系统</p><p>本文总结了如何在butterfly主题的hexo博客中添加Valine评论功能</p><p>附带一下午的踩坑经验</p><h2 id="开启Valine"><a href="#开启Valine" class="headerlink" title="开启Valine"></a>开启Valine</h2><h3 id="注册leancloud"><a href="#注册leancloud" class="headerlink" title="注册leancloud"></a>注册leancloud</h3><p><a href="https://www.leancloud.cn/" target="_blank" rel="noopener">leancloud注册官网</a></p><p>注册完以后需要创建一个应用，名字可以随便起，然后 进入应用-&gt;设置-&gt;应用key</p><p>获取你的appid 和 appkey 如图所示：</p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/19/UWuIzR.png" alt=""></p><p>拿到你的appid和appkey之后，打开butterfly.yml主题配置文件 搜索 valine，填入appid 和 appkey</p><p>我的配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">valine:</span><br><span class="line">  enable: true</span><br><span class="line">  appId: </span><br><span class="line">  appKey: </span><br><span class="line">  notify: false </span><br><span class="line">  verify: false </span><br><span class="line">  placeholder: 欢迎留言~</span><br><span class="line">  avatar: retro</span><br><span class="line">  guest_info: nick,mail,link </span><br><span class="line">  pageSize: 10 </span><br><span class="line">  ...</span><br></pre></td></tr></table></figure><p>到这儿还没有结束，不要忘记在butterfly.yml主题配置文件中添加comments配置，博主就是忘记配置comments踩坑了一个下午，查阅了好多网友的经验文章，终于找到为什么不显示的原因，加上以下语句就可以正常显示评论面板了。</p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/19/UWKHpj.png" alt=""></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://blog.csdn.net/blue_zy/article/details/79071414" target="_blank" rel="noopener">为你的Hexo加上评论系统-Valine</a></p><p><a href="https://valine.js.org/avatar.html" target="_blank" rel="noopener">valine官方文档</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="Hexo" scheme="http://yoursite.com/categories/Hexo/"/>
    
    
      <category term="Valine" scheme="http://yoursite.com/tags/Valine/"/>
    
  </entry>
  
</feed>
