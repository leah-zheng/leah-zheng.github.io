<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Leah&#39;s blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-08-12T08:15:24.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Leah Zheng</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>02-运算符、判断分支、注释</title>
    <link href="http://yoursite.com/2020/08/12/02-%E8%AF%AD%E6%B3%95%E3%80%81%E8%A7%84%E8%8C%83%E3%80%81%E9%94%99%E8%AF%AF%E3%80%81%E8%BF%90%E7%AE%97%E7%AC%A6%E3%80%81%E5%88%A4%E6%96%AD%E5%88%86%E6%94%AF%E3%80%81%E6%B3%A8%E9%87%8A/"/>
    <id>http://yoursite.com/2020/08/12/02-%E8%AF%AD%E6%B3%95%E3%80%81%E8%A7%84%E8%8C%83%E3%80%81%E9%94%99%E8%AF%AF%E3%80%81%E8%BF%90%E7%AE%97%E7%AC%A6%E3%80%81%E5%88%A4%E6%96%AD%E5%88%86%E6%94%AF%E3%80%81%E6%B3%A8%E9%87%8A/</id>
    <published>2020-08-12T08:15:24.000Z</published>
    <updated>2020-08-12T08:15:24.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="语法、规范、运算符、判断分支、注释"><a href="#语法、规范、运算符、判断分支、注释" class="headerlink" title="语法、规范、运算符、判断分支、注释"></a>语法、规范、运算符、判断分支、注释</h1><h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><p> <strong>// +  -  *  /  % （）</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>,</span><br><span class="line">b = <span class="number">2</span>,</span><br><span class="line">d = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">var</span> c = (a + b) * d;</span><br></pre></td></tr></table></figure><p>声明变量c</p><p>=&gt;变量a的值和变量b的值相加，再与变量d的值相乘得到结果</p><p>=&gt;将该结果赋值给变量c</p><p>总结：括号运算&gt;普通运算&gt;赋值</p><p><strong>// + 数学运算</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span> + <span class="string">'str'</span>  <span class="comment">// '1str'</span></span><br><span class="line"><span class="keyword">var</span> b = <span class="string">'str'</span> + <span class="literal">undefined</span> <span class="comment">// 'strundefined'</span></span><br><span class="line"><span class="keyword">var</span> c = <span class="string">'str'</span> + <span class="literal">NaN</span> <span class="comment">//'strNaN'</span></span><br><span class="line"><span class="comment">//任何数据类型的值+字符串都是字符串</span></span><br></pre></td></tr></table></figure><p><strong>// / 除法</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">0</span> / <span class="number">0</span>;  <span class="comment">// NaN(not a number非数)=&gt;数字类型</span></span><br><span class="line"><span class="keyword">var</span> b = <span class="string">'a'</span> / <span class="string">'b'</span> <span class="comment">// NaN</span></span><br><span class="line"><span class="keyword">var</span> c = <span class="number">1</span> / <span class="number">0</span> <span class="comment">//infinity =&gt;数字类型</span></span><br></pre></td></tr></table></figure><p><strong>// % 取余</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="number">3</span> % <span class="number">4</span>) <span class="comment">// 3</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">4</span> % <span class="number">3</span>) <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p><strong>交换值的问题</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>,</span><br><span class="line">b = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">var</span> c = a;</span><br><span class="line">a = b;</span><br><span class="line">b = c;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = a + b;  <span class="comment">// 3</span></span><br><span class="line">b = a - b;  <span class="comment">// 1</span></span><br><span class="line">a = a - b;<span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p><strong>// ++  –</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a++)  <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(a)  <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log(++a)  <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><p>案例题:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">5</span>,</span><br><span class="line">b;</span><br><span class="line">b = a++ + <span class="number">1</span>;</span><br><span class="line"><span class="built_in">console</span>.log(b, a)<span class="comment">// 6,6</span></span><br><span class="line">b = ++a + <span class="number">1</span>;</span><br><span class="line"><span class="built_in">console</span>.log(b, a)   <span class="comment">// 7,6</span></span><br><span class="line">b = a-- + --a      </span><br><span class="line"><span class="built_in">console</span>.log(b, a)<span class="comment">// 8,3</span></span><br><span class="line">b = --a + --a</span><br><span class="line"><span class="built_in">console</span>.log(b, a)<span class="comment">// 7,3</span></span><br><span class="line">b = --a + a++</span><br><span class="line"><span class="built_in">console</span>.log(b, a)<span class="comment">// 8,5</span></span><br></pre></td></tr></table></figure><p><strong>// 比较运算符 &gt; &lt; &gt;= &lt;= == === !== !=</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> bool = <span class="number">1</span> &lt; <span class="number">2</span> <span class="comment">// true</span></span><br><span class="line"><span class="keyword">var</span> bool = <span class="number">1</span> &gt; <span class="number">2</span> <span class="comment">// false</span></span><br><span class="line"><span class="keyword">var</span> bool = <span class="number">1</span> &gt; <span class="string">'2'</span> <span class="comment">// false</span></span><br><span class="line"><span class="comment">//number对string=&gt;number</span></span><br><span class="line"><span class="keyword">var</span> bool = <span class="string">'a'</span> &gt; <span class="string">'b'</span> <span class="comment">// false</span></span><br><span class="line"><span class="keyword">var</span> bool = <span class="string">'4.5'</span>&gt;<span class="string">'11'</span> <span class="comment">// true</span></span><br><span class="line"><span class="comment">//字符串相对应的ASCII码(字符相对应的十进制代码)多个字符的，从左到右依次对比，直到比较出ASCII码的大小为止</span></span><br><span class="line"><span class="keyword">var</span> bool = <span class="number">1</span> == <span class="string">'1'</span> <span class="comment">// true</span></span><br><span class="line"><span class="keyword">var</span> bool = <span class="number">1</span> === <span class="string">'1'</span> <span class="comment">// false</span></span><br><span class="line"><span class="comment">//相等不看数据类型，全等要看数据类型是否相等</span></span><br><span class="line"><span class="keyword">var</span> bool = <span class="number">1</span> !== <span class="string">'1'</span> <span class="comment">//true</span></span><br><span class="line"><span class="comment">//不全等与全等相同，要看数据类型</span></span><br><span class="line"><span class="keyword">var</span> bool = <span class="literal">NaN</span> == <span class="literal">NaN</span>  <span class="comment">//false</span></span><br><span class="line"><span class="comment">//NaN与包括自己在内任何东西都不相等</span></span><br></pre></td></tr></table></figure><p><strong>逻辑运算符</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A &amp;&amp; B <span class="comment">// A与B 两边都必须满足条件</span></span><br><span class="line">A || B <span class="comment">// A或B 其中一边满足条件即可</span></span><br><span class="line">!A     <span class="comment">// 非A</span></span><br></pre></td></tr></table></figure><p>undefined、null、NaN、””、0都是假false</p><p>除以上以外都是真 true</p><p><strong>逻辑运算</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">var a &#x3D; 1 &amp;&amp; 2; </span><br><span class="line">&#x2F;&#x2F;遇到真就往后走，</span><br><span class="line">遇到假或走到最后一个就返回当前值</span><br><span class="line">var b &#x3D; 1 || 2;</span><br><span class="line">&#x2F;&#x2F;遇到假就往后走，</span><br><span class="line">遇到真或者走到最后就返回当前值</span><br><span class="line">console.log(a, b) &#x2F;&#x2F; 2,1</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;1 &amp;&amp; 1 返回1  真</span><br><span class="line">&#x2F;&#x2F;1 &amp;&amp; 0 返回0  假</span><br><span class="line">&#x2F;&#x2F;0 &amp;&amp; 1 返回0  假</span><br><span class="line">&#x2F;&#x2F;0 &amp;&amp; 0 返回0  假</span><br><span class="line">&#x2F;&#x2F;1 || 1 返回1  真</span><br><span class="line">&#x2F;&#x2F;1 || 0 返回1  真</span><br><span class="line">&#x2F;&#x2F;0 || 1 返回1  真</span><br><span class="line">&#x2F;&#x2F;0 || 0 返回0  假</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var a &#x3D; !1  &#x2F;&#x2F;false</span><br><span class="line">a &#x3D; !a  &#x2F;&#x2F; 取反</span><br></pre></td></tr></table></figure><h2 id="判断分支"><a href="#判断分支" class="headerlink" title="判断分支"></a>判断分支</h2><p><strong>判断范围或值为多个时用if语句</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(判断条件)&#123;</span><br><span class="line">...</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>判断定值时用switch</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>(变量)&#123;</span><br><span class="line"><span class="keyword">case</span> 值：</span><br><span class="line">语句；</span><br><span class="line"><span class="keyword">break</span>；</span><br><span class="line"><span class="keyword">case</span> 值：</span><br><span class="line">语句；</span><br><span class="line"><span class="keyword">break</span>；</span><br><span class="line">...</span><br><span class="line"><span class="keyword">default</span> 语句；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>两种方法实现判断成绩等级：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> score = <span class="number">78</span>；</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(score &lt;= <span class="number">100</span> &amp;&amp; score &gt;=<span class="number">90</span> )&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'A'</span>);</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(score &gt;= <span class="number">80</span>) &#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'B'</span>)</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(score &gt;= <span class="number">70</span>)&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'C'</span>)</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(score &gt;= <span class="number">60</span>)&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'D'</span>)</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(score &gt;= <span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'不合格'</span>)</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'成绩出现异常'</span>)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">switch</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">    <span class="keyword">case</span> score &lt;= <span class="number">100</span> &amp;&amp; score &gt;=<span class="number">90</span>:</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'A'</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> score &gt;= <span class="number">80</span> &amp;&amp; score &lt;=<span class="number">90</span>:</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'B'</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> score &gt;= <span class="number">70</span> &amp;&amp; score &lt;=<span class="number">80</span>:</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'C'</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> score &gt;= <span class="number">60</span> &amp;&amp; score &lt;=<span class="number">70</span>:</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'D'</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> score &gt;= <span class="number">0</span> &amp;&amp; score &lt;=<span class="number">60</span>:</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'不合格'</span>);</span><br><span class="line">        <span class="keyword">break</span>;    </span><br><span class="line">    <span class="keyword">default</span>：</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'成绩出现异常'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//行注释</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *块注释</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="ECMAscript" scheme="http://yoursite.com/categories/ECMAscript/"/>
    
    
      <category term="运算符" scheme="http://yoursite.com/tags/%E8%BF%90%E7%AE%97%E7%AC%A6/"/>
    
      <category term="判断分支" scheme="http://yoursite.com/tags/%E5%88%A4%E6%96%AD%E5%88%86%E6%94%AF/"/>
    
  </entry>
  
  <entry>
    <title>01-发展史、ECMA、编程语言、变量、JS值</title>
    <link href="http://yoursite.com/2020/08/12/01-%E5%8F%91%E5%B1%95%E5%8F%B2%E3%80%81ECMA%E3%80%81%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E3%80%81%E5%8F%98%E9%87%8F%E3%80%81JS%E5%80%BC/"/>
    <id>http://yoursite.com/2020/08/12/01-%E5%8F%91%E5%B1%95%E5%8F%B2%E3%80%81ECMA%E3%80%81%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E3%80%81%E5%8F%98%E9%87%8F%E3%80%81JS%E5%80%BC/</id>
    <published>2020-08-12T04:45:25.000Z</published>
    <updated>2020-08-12T04:45:25.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="5大主流浏览器的内核"><a href="#5大主流浏览器的内核" class="headerlink" title="5大主流浏览器的内核"></a>5大主流浏览器的内核</h2><ul><li>IE    trident</li><li>chrome    webkit blink</li><li>safari        webkit</li><li>firefox       gecko</li><li>opera        presto</li></ul><h2 id="浏览器的历史和js诞生"><a href="#浏览器的历史和js诞生" class="headerlink" title="浏览器的历史和js诞生"></a>浏览器的历史和js诞生</h2><ol><li><p>1990    蒂姆·伯纳斯·李  超文本分享资讯的人</p><p>world wide web 移植到C  =&gt;libwww=&gt;nexus</p><p>允许别人浏览他人编写的网站</p></li><li><p>1993  美国伊利诺大学NCSA组织（马克·安德森）开发了MOSIAC浏览器（图形化浏览器）能够显示图片</p></li><li><p>1994  马克·安德森和吉姆·克拉克（硅图SGI）成立MOSIAC communication corporation</p><p>MOSIAC =&gt;伊利诺大学=&gt;spy glass公司=&gt;Netscape communication corporation</p><p>网景公司=&gt;Netscape navigator  =&gt;2003</p></li><li><p>1996  </p><ol><li>微软的公司收购spy glass</li></ol><p>=&gt;IE  1.0</p><p>​    IE3  JScript</p><p>​    2. 网景公司Brendan eich在Netscape navigator开发出了livescript(javascript前生) </p><ol start="3"><li>SUN的JAVA有知名度，网景livescript不温不火，网景与sun合作推广和宣传产品，livescript=&gt;javascript</li></ol></li><li><p>2001  IE6 xp诞生</p><p>​            JS引擎</p></li><li><p>2003   Mozilla公司  firefox =&gt; 根据Netscape navigator复制</p></li><li><p>2008   google基于webkit blink gears</p><p>chrome =&gt;V8=&gt;JS引擎</p><ol><li>直接翻译机器码</li><li>独立于浏览器运行</li></ol></li><li><p>2009  甲骨文oracle收购了sun公司</p><p>​            JS 所有权给甲骨文</p></li></ol><h2 id="ECMA"><a href="#ECMA" class="headerlink" title="ECMA"></a>ECMA</h2><p>European Computer Manufactures Association 欧洲计算机制造联合会</p><p>评估、开发、认可电信、计算机标准</p><p>ECMA-262 脚本语言规范  ECMAScript</p><p>ES5 ES6 规范化脚本语言</p><h2 id="编程语言"><a href="#编程语言" class="headerlink" title="编程语言"></a>编程语言</h2><p>高级语言：人能理解机器不能理解</p><p>编译器  解释器</p><p>翻译过程不同：</p><p>编译性语言：源码=&gt;编译器=&gt;机器语言=&gt;可执行的文件；适合写逻辑性强的大型项目</p><p>解释性语言：源码=&gt;解释器=&gt;解释一行执行一行； 不需要根据不同的系统平台进行移植，速度更快一些，</p><p>.java =&gt;javac=&gt;.class=&gt;JVM解释执行</p><p>C++ .cpp源码=&gt;编译器=&gt;.s汇编=&gt;汇编器=&gt;.obj目标代码=&gt;链接器=&gt;可执行文件</p><p>脚本语言：</p><p>​    =&gt;脚本引擎=&gt;解释器</p><p>javascript客户端脚本：解释器在浏览器</p><p> php服务端脚本：解释器在服务器</p><h2 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h2><p>ECMAscript</p><p>DOM  document object model  W3C</p><p>BOM  browser object model   没有规范</p><p>JS引擎是单线程引擎</p><p>单线程：一次只能执行一个任务</p><p>​                =&gt;如何模拟多线程  </p><p>​    轮转时间片：短时间之内轮流执行多个任务片段</p><ol><li>任务1 任务2…</li><li>切分任务</li><li>随机排列任务片段，组成队列</li><li>按照这个队列顺序将任务片段送进JS进程</li><li>JS线程执行一个又一个的任务片段</li></ol><p>多线程：一次能同时执行多个任务</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type&#x3D;&#39;text&#x2F;javascript&#39;&gt;&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><p>编程语言必备：变量、数据结构、函数、运算能力</p><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a;  <span class="comment">//变量声明</span></span><br><span class="line">a=<span class="number">3</span>;<span class="comment">//变量赋值</span></span><br><span class="line"><span class="keyword">var</span> a=<span class="number">3</span> <span class="comment">//变量声明并赋值</span></span><br></pre></td></tr></table></figure><p>变量命名规范：</p><ul><li>不能以数字开头，能字母_$开头</li><li>变量里可以包含字母_$数字</li><li>不能以关键字、保留字命名</li><li>驼峰命名法 小驼峰 大驼峰</li></ul><p><strong>先运算&gt;再赋值</strong></p><h2 id="JS值"><a href="#JS值" class="headerlink" title="JS值"></a>JS值</h2><h3 id="原始值-gt-基本类型（5种）"><a href="#原始值-gt-基本类型（5种）" class="headerlink" title="原始值-&gt;基本类型（5种）"></a>原始值-&gt;基本类型（5种）</h3><ul><li>Number 数字</li><li>String 字符串</li><li>Boolean 布尔值</li><li>undefined 未被定义</li><li>null 空值</li></ul><h3 id="引用值"><a href="#引用值" class="headerlink" title="引用值"></a>引用值</h3><ul><li>object</li><li>array</li><li>function</li><li>date</li><li>RegExp</li></ul><h3 id="变量空间存储原始值和引用值"><a href="#变量空间存储原始值和引用值" class="headerlink" title="变量空间存储原始值和引用值"></a>变量空间存储原始值和引用值</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">3</span>,</span><br><span class="line">b = a;</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>原始值存储在栈内存，先进后出。重新给a赋值会开辟新的内存空间并赋值，原来的值保持不变，只是对应的名称不在了。</p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/08/12/ajOhKf.png" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var arr1 &#x3D; [1,2,3,4,5],</span><br><span class="line">arr2 &#x3D; arr1;</span><br><span class="line">var arr1 &#x3D; [1,2];</span><br></pre></td></tr></table></figure><p>引用值的实际数据存储在堆内存，而栈内存中存储的只是指向堆内存的地址。将arr1的值赋值给arr2，其实就指向同一个堆内存的地址。</p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/08/12/ajjWB8.png" alt=""></p><p>给arr1重新赋值就是在栈内存中开启新的空间，存储指向存在堆内存中的新数据的地址。</p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/08/12/ajv93R.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="ECMAscript" scheme="http://yoursite.com/categories/ECMAscript/"/>
    
    
      <category term="ECMAscript" scheme="http://yoursite.com/tags/ECMAscript/"/>
    
      <category term="变量" scheme="http://yoursite.com/tags/%E5%8F%98%E9%87%8F/"/>
    
      <category term="JS值" scheme="http://yoursite.com/tags/JS%E5%80%BC/"/>
    
  </entry>
  
  <entry>
    <title>16-数组与数组的方法</title>
    <link href="http://yoursite.com/2020/08/11/25-%E6%95%B0%E7%BB%84%E5%8F%8A%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95/"/>
    <id>http://yoursite.com/2020/08/11/25-%E6%95%B0%E7%BB%84%E5%8F%8A%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95/</id>
    <published>2020-08-11T05:16:24.000Z</published>
    <updated>2020-08-11T15:01:44.553Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="一、-创建数组的方式"><a href="#一、-创建数组的方式" class="headerlink" title="一、 创建数组的方式"></a>一、 创建数组的方式</h2><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr1 = [];</span><br><span class="line"><span class="keyword">var</span> arr2 = <span class="keyword">new</span> <span class="built_in">Array</span>(); <span class="comment">// 填一个数字参数表示数组的长度</span></span><br><span class="line"><span class="keyword">var</span> arr3 = <span class="built_in">Array</span>()</span><br></pre></td></tr></table></figure><p>所有的数组方法与属性都继承于Array.prototype。</p><h2 id="二、数组的方法"><a href="#二、数组的方法" class="headerlink" title="二、数组的方法"></a>二、数组的方法</h2><h3 id="1-返回修改后的原数组"><a href="#1-返回修改后的原数组" class="headerlink" title="1. 返回修改后的原数组"></a>1. 返回修改后的原数组</h3><ul><li><p><strong>push() / unshift()</strong> </p><p>返回值是执行了方法以后的数组<strong>长度</strong>。</p></li><li><p><strong>pop() / shift()</strong>  [<strong>无参数</strong>]</p><p>剪切从后至前或从前至后的第一位</p><p>返回值是被删除的值</p></li><li><p><strong>reverse()</strong>  倒序</p></li><li><p><strong>splice(开始项的下标,剪切长度,在剪切位置添加的数据)</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>];</span><br><span class="line">arr.splice(<span class="number">3</span>,<span class="number">0</span>,<span class="number">4</span>)  <span class="comment">//[1,2,3,4]  在开始项的前面添加数据</span></span><br><span class="line">arr.splice(<span class="number">-1</span>,<span class="number">0</span>,<span class="number">4</span>)  <span class="comment">//[1,2,3,4]</span></span><br></pre></td></tr></table></figure></li><li><p><strong>sort()</strong>  按照ASCII码排序</p><ol><li>参数a和b</li><li>返回值<ul><li>正值，a&gt;b,b排前</li><li>负值，b&gt;a,a排前</li><li>0，保持不动</li></ul></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">arr.sort(<span class="function"><span class="keyword">function</span>(<span class="params">a,b</span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> a-b&gt;<span class="number">0</span> ? <span class="number">-1</span> : <span class="number">1</span></span><br><span class="line">或</span><br><span class="line"><span class="keyword">return</span> a-b</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>//sort随机排序</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">arr.sort(<span class="function"><span class="keyword">function</span>(<span class="params">a.b</span>)</span>&#123;</span><br><span class="line"><span class="keyword">var</span> rand = <span class="built_in">Math</span>.random();</span><br><span class="line"><span class="keyword">return</span> rand<span class="number">-0.5</span>&gt;<span class="number">0</span> ? <span class="number">1</span> : <span class="number">-1</span>;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ul><h3 id="2-返回修改后的新数组"><a href="#2-返回修改后的新数组" class="headerlink" title="2. 返回修改后的新数组"></a>2. 返回修改后的新数组</h3><ul><li><p><strong>concat()</strong></p><p>拼接两数组，返回新数组</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr1 = [<span class="number">1</span>, <span class="number">2</span>],</span><br><span class="line">arr2 = [<span class="number">3</span>, <span class="number">4</span>],</span><br><span class="line">arr3 = arr1.concat(arr2) <span class="comment">// [1, 2, 3, 4]</span></span><br></pre></td></tr></table></figure></li><li><p><strong>toString()</strong></p></li><li><p><strong>slice()</strong></p><p>[start, end) 从start开始，到end之前截取，并返回新数组</p></li><li><p><strong>join()</strong></p><p>将数组中的元素组成新的字符串，传入的参数是分隔符。</p></li><li><p><strong>split()</strong></p><p>与join()配合使用，将字符串按照分隔符分隔，重新生成数组。</p><p>第一个参数为分隔符，第二个参数为截取的长度</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="array" scheme="http://yoursite.com/categories/array/"/>
    
    
      <category term="array" scheme="http://yoursite.com/tags/array/"/>
    
  </entry>
  
  <entry>
    <title>15-js浅拷贝与深拷贝的区别和实现方式</title>
    <link href="http://yoursite.com/2020/08/10/24-%E6%B5%85%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B7%B1%E6%8B%B7%E8%B4%9D/"/>
    <id>http://yoursite.com/2020/08/10/24-%E6%B5%85%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B7%B1%E6%8B%B7%E8%B4%9D/</id>
    <published>2020-08-10T07:14:53.000Z</published>
    <updated>2020-08-10T15:43:06.877Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id=""><a href="#" class="headerlink" title=""></a></h1><h5 id="如何区分深拷贝与浅拷贝，简单点来说，就是假设B复制了A，当修改A时，看B是否会发生变化，如果B也跟着变了，说明这是浅拷贝，拿人手短，如果B没变，那就是深拷贝，自食其力。"><a href="#如何区分深拷贝与浅拷贝，简单点来说，就是假设B复制了A，当修改A时，看B是否会发生变化，如果B也跟着变了，说明这是浅拷贝，拿人手短，如果B没变，那就是深拷贝，自食其力。" class="headerlink" title="如何区分深拷贝与浅拷贝，简单点来说，就是假设B复制了A，当修改A时，看B是否会发生变化，如果B也跟着变了，说明这是浅拷贝，拿人手短，如果B没变，那就是深拷贝，自食其力。"></a>如何区分深拷贝与浅拷贝，简单点来说，就是假设B复制了A，当修改A时，看B是否会发生变化，如果B也跟着变了，说明这是浅拷贝，拿人手短，如果B没变，那就是深拷贝，自食其力。</h5><h3 id="1-如果是基本数据类型，名字和值都会储存在栈内存中"><a href="#1-如果是基本数据类型，名字和值都会储存在栈内存中" class="headerlink" title="1. 如果是基本数据类型，名字和值都会储存在栈内存中"></a>1. 如果是基本数据类型，名字和值都会储存在栈内存中</h3><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line">b = a; <span class="comment">// 栈内存会开辟一个新的内存空间，此时b和a都是相互独立的</span></span><br><span class="line">b = <span class="number">2</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p>当然，这也算不上深拷贝，因为深拷贝本身只针对较为复杂的object类型数据。</p><h3 id="2-如果是引用数据类型，名字存在栈内存中，值存在堆内存中，但是栈内存会提供一个引用的地址指向堆内存中的值"><a href="#2-如果是引用数据类型，名字存在栈内存中，值存在堆内存中，但是栈内存会提供一个引用的地址指向堆内存中的值" class="headerlink" title="2. 如果是引用数据类型，名字存在栈内存中，值存在堆内存中，但是栈内存会提供一个引用的地址指向堆内存中的值"></a>2. 如果是引用数据类型，名字存在栈内存中，值存在堆内存中，但是栈内存会提供一个引用的地址指向堆内存中的值</h3><h5 id="比如浅拷贝："><a href="#比如浅拷贝：" class="headerlink" title="比如浅拷贝："></a>比如浅拷贝：</h5><p><img src= "/img/loading.gif" data-src="https:////upload-images.jianshu.io/upload_images/15037426-33f5ceb9d7cb0a6e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/500/format/webp" alt="img"></p><p>当b=a进行拷贝时，其实复制的是a的引用地址，而并非堆里面的值。</p><p><img src= "/img/loading.gif" data-src="https:////upload-images.jianshu.io/upload_images/15037426-7bf9efc3a6e90bea.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/500/format/webp" alt="img"></p><p>而当我们a[0]=1时进行数组修改时，由于a与b指向的是同一个地址，所以自然b也受了影响，这就是所谓的浅拷贝了。</p><p><img src= "/img/loading.gif" data-src="https:////upload-images.jianshu.io/upload_images/15037426-aba3349a798ab52b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/500/format/webp" alt="img"></p><p> 那，要是在堆内存中也开辟一个新的内存专门为b存放值，就像基本类型那样，岂不就达到深拷贝的效果了</p><p><img src= "/img/loading.gif" data-src="https:////upload-images.jianshu.io/upload_images/15037426-3cc2e0e955d177e3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/500/format/webp" alt="img"></p><h3 id="3-实现浅拷贝的方法"><a href="#3-实现浅拷贝的方法" class="headerlink" title="3. 实现浅拷贝的方法"></a>3. 实现浅拷贝的方法</h3><p>（1）for···in只循环第一层</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 只复制第一层的浅拷贝</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">simpleCopy</span>(<span class="params">obj1</span>) </span>&#123;</span><br><span class="line">   <span class="keyword">var</span> obj2 = <span class="built_in">Array</span>.isArray(obj1) ? [] : &#123;&#125;;</span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">in</span> obj1) &#123;</span><br><span class="line">   obj2[i] = obj1[i];</span><br><span class="line">  &#125;</span><br><span class="line">   <span class="keyword">return</span> obj2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj1 = &#123;</span><br><span class="line">   a: <span class="number">1</span>,</span><br><span class="line">   b: <span class="number">2</span>,</span><br><span class="line">   c: &#123;</span><br><span class="line">         d: <span class="number">3</span></span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj2 = simpleCopy(obj1);</span><br><span class="line">obj2.a = <span class="number">3</span>;</span><br><span class="line">obj2.c.d = <span class="number">4</span>;</span><br><span class="line">alert(obj1.a); <span class="comment">// 1</span></span><br><span class="line">alert(obj2.a); <span class="comment">// 3</span></span><br><span class="line">alert(obj1.c.d); <span class="comment">// 4</span></span><br><span class="line">alert(obj2.c.d); <span class="comment">// 4</span></span><br></pre></td></tr></table></figure><p>（2）Object.assign方法</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    a: <span class="number">1</span>,</span><br><span class="line">    b: <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj1 = <span class="built_in">Object</span>.assign(obj);</span><br><span class="line">obj1.a = <span class="number">3</span>;</span><br><span class="line"><span class="built_in">console</span>.log(obj.a) <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><p>（3）直接用=赋值</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a=[<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>],</span><br><span class="line">    b=a;</span><br><span class="line"><span class="built_in">console</span>.log(a===b);</span><br><span class="line">a[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a,b);</span><br></pre></td></tr></table></figure><h3 id="4-实现深拷贝的方法"><a href="#4-实现深拷贝的方法" class="headerlink" title="4. 实现深拷贝的方法"></a>4. 实现深拷贝的方法</h3><p>（1）采用递归去拷贝所有层级属性</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepclone</span>(<span class="params">origin, target</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> tar = target || &#123;&#125;;</span><br><span class="line">        <span class="keyword">let</span> objToString = <span class="built_in">Object</span>.prototype.toString;</span><br><span class="line">        <span class="keyword">let</span> arrType = <span class="string">'[object Array]'</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> origin) &#123;</span><br><span class="line">            <span class="keyword">if</span> (origin.hasOwnProperty(key)) &#123;</span><br><span class="line">               <span class="keyword">if</span> (<span class="keyword">typeof</span>(origin[key]) === <span class="string">'object'</span> &amp;&amp; origin[key] !== <span class="literal">null</span>) &#123;</span><br><span class="line">                   objToString.call(origin[key]) === arrType ? tar[key] = [] </span><br><span class="line">                      : tar[key] = &#123;&#125;;</span><br><span class="line">                   deepclone(origin[key], tar[key])</span><br><span class="line">                  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                      tar[key] = origin[key]</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">return</span> tar</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="深/浅拷贝" scheme="http://yoursite.com/categories/%E6%B7%B1-%E6%B5%85%E6%8B%B7%E8%B4%9D/"/>
    
    
      <category term="深/浅拷贝" scheme="http://yoursite.com/tags/%E6%B7%B1-%E6%B5%85%E6%8B%B7%E8%B4%9D/"/>
    
  </entry>
  
  <entry>
    <title>14-对象继承及圣杯模式函数封装</title>
    <link href="http://yoursite.com/2020/08/09/23-%E5%AF%B9%E8%B1%A1%E7%BB%A7%E6%89%BF%E4%B9%8B%E5%9C%A3%E6%9D%AF%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2020/08/09/23-%E5%AF%B9%E8%B1%A1%E7%BB%A7%E6%89%BF%E4%B9%8B%E5%9C%A3%E6%9D%AF%E6%A8%A1%E5%BC%8F/</id>
    <published>2020-08-09T05:54:32.000Z</published>
    <updated>2020-08-09T15:41:55.607Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="一、对象的继承"><a href="#一、对象的继承" class="headerlink" title="一、对象的继承"></a>一、对象的继承</h2><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//--------继承------------</span></span><br><span class="line"> <span class="comment">//第一步：创建Father的原型属性</span></span><br><span class="line"> <span class="comment">//Ps:Father.prototype是一个构造函数</span></span><br><span class="line"> Father.prototype.lastName = <span class="string">"林"</span></span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">Father</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//第二步：创建Son的构造函数</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">Son</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"> <span class="comment">//第三步：现在我们想让Son继承Father的原型</span></span><br><span class="line">   <span class="function"><span class="keyword">function</span> <span class="title">inherit</span>(<span class="params">Taret, Origin</span>) </span>&#123;</span><br><span class="line">         Taret.prototype = Origin.prototype</span><br><span class="line">            &#125;</span><br><span class="line">  <span class="comment">// 第四步：调用继承的方法，并创建Son的一个对象</span></span><br><span class="line">     inherit(Son, Father)</span><br><span class="line">     <span class="keyword">var</span> father = <span class="keyword">new</span> Father()</span><br><span class="line">     <span class="keyword">var</span> son = <span class="keyword">new</span> Son()</span><br><span class="line"> <span class="comment">//PS:此时son.lastName和father.lastName都能打印出“林”的信息</span></span><br><span class="line"> <span class="comment">//因为它们指向的是同一个 Father.prototype.lastName</span></span><br></pre></td></tr></table></figure><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ---------那么一个问题来了，如果我们要个son的原型添加属性时，father的原型是否也会随之添加？？？-------</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">//第一步：创建Father的原型属性</span></span><br><span class="line">  <span class="comment">//Ps:Father.prototype是一个构造函数</span></span><br><span class="line">  Father.prototype.lastName = <span class="string">"林"</span></span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">Father</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//第二步：创建Son的构造函数</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">Son</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">  <span class="comment">//第三步：现在我们想让Son继承Father的原型</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">inherit</span>(<span class="params">Taret, Origin</span>) </span>&#123;</span><br><span class="line">      Taret.prototype = Origin.prototype</span><br><span class="line">        &#125;</span><br><span class="line"> <span class="comment">// 第四步：调用继承的方法，并创建Son的一个对象</span></span><br><span class="line">    inherit(Son, Father)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 第五步：我们给son的原型添加原型属性的age时，father也会有age的属性，</span></span><br><span class="line"> <span class="comment">// 因为它们指向的是同一个原型地址Father的原型</span></span><br><span class="line">  Son.prototype.age = <span class="string">"24岁"</span></span><br><span class="line">  <span class="keyword">var</span> father = <span class="keyword">new</span> Father()</span><br><span class="line">  <span class="keyword">var</span> son = <span class="keyword">new</span> Son()</span><br><span class="line">  <span class="comment">//Ps:这样就不符合要求了，我们只是想给son添加原型属性，但father也会受到影响</span></span><br></pre></td></tr></table></figure><h2 id="二、圣杯模式"><a href="#二、圣杯模式" class="headerlink" title="二、圣杯模式"></a>二、圣杯模式</h2><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// -----------圣杯模式，他是解决上面father受污染的问题-----------------------</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//第一步：创建Father的原型属性</span></span><br><span class="line">        <span class="comment">//Ps:Father.prototype是一个构造函数</span></span><br><span class="line">        Father.prototype.lastName = <span class="string">"李白"</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">Father</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">        <span class="comment">// 第二步：创建一个构造函数，以它作为一个中间层</span></span><br><span class="line">        Intermediate.prototype = Father.prototype</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">Intermediate</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">        <span class="comment">// 第三步：让son的原型继自中间层函数创建的一个对象</span></span><br><span class="line">        Son.prototype = <span class="keyword">new</span> Intermediate()</span><br><span class="line">            <span class="comment">//new Intermediate()创建出的一个对象是独立的个体，并且也继承了 Father.prototype.lastName</span></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">Son</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">        <span class="comment">//第四步：现在如果给Son的原型添加原型属性age,Father的原型是否会受到影响呢？？？？</span></span><br><span class="line">        Son.prototype.age = <span class="string">"200岁"</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//第五步：给Son和Father创建一个对象</span></span><br><span class="line">        <span class="keyword">var</span> father = <span class="keyword">new</span> Father()</span><br><span class="line">        <span class="keyword">var</span> son = <span class="keyword">new</span> Son()</span><br><span class="line">            <span class="comment">//Ps：我们给Son添加原型属性，Father是不受到影响的，这就达到了我们的目的</span></span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/08/09/a7Rq6U.png" alt=""></p><h2 id="三、继承函数的封装"><a href="#三、继承函数的封装" class="headerlink" title="三、继承函数的封装"></a>三、继承函数的封装</h2><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//为了防止全局环境的污染，利于企业合作二次开发</span></span><br><span class="line"><span class="keyword">var</span> inherit=(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">var</span> Buffer = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">Target,Origin</span>) </span>&#123;</span><br><span class="line">Buffer.prototype = Origin.prototype;</span><br><span class="line">Target.prototype = <span class="keyword">new</span> Buffer();</span><br><span class="line">Target.prototype.constructor = Target;</span><br><span class="line">Target.prototype.super_class=Origin;</span><br><span class="line">&#125;</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="对象继承" scheme="http://yoursite.com/categories/%E5%AF%B9%E8%B1%A1%E7%BB%A7%E6%89%BF/"/>
    
      <category term="圣杯模式" scheme="http://yoursite.com/categories/%E5%AF%B9%E8%B1%A1%E7%BB%A7%E6%89%BF/%E5%9C%A3%E6%9D%AF%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="对象继承" scheme="http://yoursite.com/tags/%E5%AF%B9%E8%B1%A1%E7%BB%A7%E6%89%BF/"/>
    
      <category term="圣杯模式" scheme="http://yoursite.com/tags/%E5%9C%A3%E6%9D%AF%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>13-JavaScript原型与原型链</title>
    <link href="http://yoursite.com/2020/08/08/22-JavaScript%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE/"/>
    <id>http://yoursite.com/2020/08/08/22-JavaScript%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE/</id>
    <published>2020-08-08T10:23:10.000Z</published>
    <updated>2020-08-08T15:04:02.847Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="一、prototype"><a href="#一、prototype" class="headerlink" title="一、prototype"></a>一、prototype</h2><p>在JavaScript中，每个函数都有一个prototype属性，这个属性指向函数的原型对象。</p><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function Person(age) &#123;</span><br><span class="line">    this.age &#x3D; age       </span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.name &#x3D; &#39;kavin&#39;</span><br><span class="line">var person1 &#x3D; new Person()</span><br><span class="line">var person2 &#x3D; new Person()</span><br><span class="line">console.log(person1.name) &#x2F;&#x2F;kavin</span><br><span class="line">console.log(person2.name)  &#x2F;&#x2F;kavin</span><br></pre></td></tr></table></figure><p>上述例子中，函数的prototype指向了一个对象，而这个对象正是调用构造函数时创建的实例的原型，也就是person1和person2的原型。</p><p>原型的概念：每一个javascript对象(除null外)创建的时候，就会与之关联另一个对象，这个对象就是我们所说的原型，每一个对象都会从原型中“继承”属性。</p><p>让我们用一张图表示构造函数和实例原型之间的关系：</p><p><img src= "/img/loading.gif" data-src="https://img2018.cnblogs.com/blog/850375/201907/850375-20190708151024134-512558007.png" alt="img"></p><h2 id="二、-proto"><a href="#二、-proto" class="headerlink" title="二、__ proto __"></a>二、__ proto __</h2><p>这是每个实例化对象(除null外)都会有的属性，叫做__ proto __，这个属性会指向该对象的原型。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function Person() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">var person &#x3D; new Person();</span><br><span class="line">console.log(person.__proto__ &#x3D;&#x3D;&#x3D; Person.prototype); &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure><p>而关系图：</p><p><img src= "/img/loading.gif" data-src="https://img2018.cnblogs.com/blog/850375/201907/850375-20190708151322530-1608157973.png" alt="img"></p><p>补充说明：</p><p>绝大部分浏览器都支持这个非标准的方法访问原型，然而它并不存在于 Person.prototype 中，实际上，它是来自于 Object.prototype ，与其说是一个属性，不如说是一个 getter/setter，当使用 obj.<strong>proto</strong> 时，可以理解成返回了 Object.getPrototypeOf(obj)。</p><h2 id="三、constructor"><a href="#三、constructor" class="headerlink" title="三、constructor"></a>三、constructor</h2><p>每个原型都有一个constructor属性，指向该关联的构造函数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function Person() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">console.log(Person&#x3D;&#x3D;&#x3D;Person.prototype.constructor)  &#x2F;&#x2F;true</span><br></pre></td></tr></table></figure><p>所以再更新下关系图：</p><p><img src= "/img/loading.gif" data-src="https://img2018.cnblogs.com/blog/850375/201907/850375-20190708151615691-1017611190.png" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function Person() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var person &#x3D; new Person();</span><br><span class="line"></span><br><span class="line">console.log(person.__proto__ &#x3D;&#x3D; Person.prototype) &#x2F;&#x2F; true</span><br><span class="line">console.log(Person.prototype.constructor &#x3D;&#x3D; Person) &#x2F;&#x2F; true</span><br><span class="line">&#x2F;&#x2F; 顺便学习一个ES5的方法,可以获得对象的原型</span><br><span class="line">console.log(Object.getPrototypeOf(person) &#x3D;&#x3D;&#x3D; Person.prototype) &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure><p>补充说明：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function Person() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">var person &#x3D; new Person();</span><br><span class="line">console.log(person.constructor &#x3D;&#x3D;&#x3D; Person); &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure><p>当获取 person.constructor 时，其实 person 中并没有 constructor 属性,当不能读取到constructor 属性时，会从 person 的原型也就是 Person.prototype 中读取，正好原型中有该属性，所以：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">person.constructor &#x3D;&#x3D;&#x3D; Person.prototype.constructor</span><br></pre></td></tr></table></figure><h2 id="四、实例与原型"><a href="#四、实例与原型" class="headerlink" title="四、实例与原型"></a>四、实例与原型</h2><p> 当读取实例的属性时，如果找不到，就会查找与对象关联的原型中的属性，如果还查不到，就去找原型的原型，一直找到最顶层为止。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function Person() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype.name &#x3D; &#39;Kevin&#39;;</span><br><span class="line"></span><br><span class="line">var person &#x3D; new Person();</span><br><span class="line"></span><br><span class="line">person.name &#x3D; &#39;Daisy&#39;;</span><br><span class="line">console.log(person.name) &#x2F;&#x2F; Daisy</span><br><span class="line"></span><br><span class="line">delete person.name;</span><br><span class="line">console.log(person.name) &#x2F;&#x2F; Kevin</span><br></pre></td></tr></table></figure><p>在这个例子中，我们给实例对象 person 添加了 name 属性，当我们打印 person.name 的时候，结果自然为 Daisy。</p><p>但是当我们删除了 person 的 name 属性时，读取 person.name，从 person 对象中找不到 name 属性就会从 person 的原型也就是 person.<strong>proto</strong> ，也就是 Person.prototype中查找，幸运的是我们找到了 name 属性，结果为 Kevin。</p><p>但是万一还没有找到呢？原型的原型又是什么呢？</p><h2 id="五、原型的原型"><a href="#五、原型的原型" class="headerlink" title="五、原型的原型"></a>五、原型的原型</h2><p> 在前面，我们已经讲了原型也是一个对象，既然是对象，我们就可以用最原始的方式创建它，那就是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var obj &#x3D; new Object();</span><br><span class="line">obj.name &#x3D; &#39;Kevin&#39;</span><br><span class="line">console.log(obj.name) &#x2F;&#x2F; Kevin</span><br></pre></td></tr></table></figure><p>其实原型对象就是通过 Object 构造函数生成的，结合之前所讲，实例的 <strong>proto</strong> 指向构造函数的 prototype ，所以我们再更新下关系图：</p><p><img src= "/img/loading.gif" data-src="https://img2018.cnblogs.com/blog/850375/201907/850375-20190708152327825-11086376.png" alt="img"></p><h2 id="六、原型链"><a href="#六、原型链" class="headerlink" title="六、原型链"></a>六、原型链</h2><p> 简单的回顾一下构造函数、原型和实例的关系：每个构造函数都有一个原型对象，原型对象都包含一个指向构造函数的指针，而实例都包含一个指向原型对象的内部指针。那么假如我们让原型对象等于另一个类型的实例，结果会怎样？显然，此时的原型对象将包含一个指向另一个原型的指针，相应地，另一个原型中也包含着一个指向另一个构造函数的指针。假如另一个原型又是另一个类型的实例，那么上述关系依然成立。如此层层递进，就构成了实例与原型的链条。这就是所谓的原型链的基本概念。——摘自《javascript高级程序设计》</p><p>其实简单来说，就是上述四-五的过程。</p><p>继上述五中所说，那 Object.prototype 的原型呢？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(Object.prototype.__proto__ &#x3D;&#x3D;&#x3D; null) &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure><p>引用阮一峰老师的 <a href="http://www.ruanyifeng.com/blog/2014/03/undefined-vs-null.html" target="_blank" rel="noopener">《undefined与null的区别》</a> 就是：</p><blockquote><p>null 表示“没有对象”，即该处不应该有值。</p></blockquote><p>所以 Object.prototype.<strong>proto</strong> 的值为 null 跟 Object.prototype 没有原型，其实表达了一个意思。</p><p>所以查找属性的时候查到 Object.prototype 就可以停止查找了。</p><p>最后一张关系图也可以更新为：</p><p><img src= "/img/loading.gif" data-src="https://img2018.cnblogs.com/blog/850375/201907/850375-20190708153139577-2105652554.png" alt="img"></p><p>图中由相互关联的原型组成的链状结构就是原型链，也就是蓝色的这条线。</p><h2 id="七、原型的用法"><a href="#七、原型的用法" class="headerlink" title="七、原型的用法"></a>七、原型的用法</h2><p>一般把组件的方法写在其原型上，需要传参配置的属性放在构造函数上。</p><p>封装插件的写法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">;(function()&#123;</span><br><span class="line">let Test &#x3D; function(name) &#123;</span><br><span class="line"> this.name &#x3D; name</span><br><span class="line">&#125;</span><br><span class="line">Test.prototype&#x3D;&#123;</span><br><span class="line">say:function()&#123;</span><br><span class="line"> console.log(this.name+&#39;said something&#39;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">window.Test &#x3D; Test;</span><br><span class="line">&#125;)()</span><br><span class="line"></span><br><span class="line">let test &#x3D; new Test(&#39;leah&#39;);</span><br><span class="line">test.say() &#x2F;&#x2F;leah said something</span><br></pre></td></tr></table></figure><p><strong>Object.create</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var obj1 &#x3D; Object.create(Obj.prototype);&#x2F;&#x2F;传入自定义原型</span><br><span class="line">var obj2 &#x3D; new Obj()</span><br></pre></td></tr></table></figure><p>以上两种方式效果相同</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="原型" scheme="http://yoursite.com/categories/%E5%8E%9F%E5%9E%8B/"/>
    
      <category term="原型链" scheme="http://yoursite.com/categories/%E5%8E%9F%E5%9E%8B/%E5%8E%9F%E5%9E%8B%E9%93%BE/"/>
    
    
      <category term="原型" scheme="http://yoursite.com/tags/%E5%8E%9F%E5%9E%8B/"/>
    
      <category term="原型链" scheme="http://yoursite.com/tags/%E5%8E%9F%E5%9E%8B%E9%93%BE/"/>
    
  </entry>
  
  <entry>
    <title>12-图解作用域、作用域链及闭包</title>
    <link href="http://yoursite.com/2020/08/04/21-%E5%9B%BE%E8%A7%A3%E4%BD%9C%E7%94%A8%E5%9F%9F%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE%E5%8F%8A%E9%97%AD%E5%8C%85/"/>
    <id>http://yoursite.com/2020/08/04/21-%E5%9B%BE%E8%A7%A3%E4%BD%9C%E7%94%A8%E5%9F%9F%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE%E5%8F%8A%E9%97%AD%E5%8C%85/</id>
    <published>2020-08-04T07:52:14.000Z</published>
    <updated>2020-08-06T15:13:26.075Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>上一篇博文已经整理关于AO与GO的知识点，现在要基于前面的知识总结作用域、作用域链及闭包。</p><h2 id="图解作用域、作用域链及闭包"><a href="#图解作用域、作用域链及闭包" class="headerlink" title="图解作用域、作用域链及闭包"></a>图解作用域、作用域链及闭包</h2><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/08/06/aRueZd.png" alt="aRueZd.png"></p><p>举上面这个函数为例，首先创建GO（全局执行上下文），GO中有test1：(function)、c：3、test3：(function)，</p><p>这时test1函数声明已被定义，所以生成了test1的[[scope]]作用域，[[scope]]中又保存了scope chain作用域链，此时作用域链的第0位储存当前环境的的GO，如下图所示：</p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/08/06/aRuVqH.png" alt="aRuVqH.png"></p><p>然后test1被执行前的预编译，函数test2被定义，生成了test2的[[scope]]，里面保存了scope chain，函数声明被定义时取上级作用域链暂时作为scope chain的内容，test2的上级作用域链是test1，所以此时test2的作用域链与test1相同。</p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/08/06/aRumdA.png" alt="aRumdA.png"></p><p>函数test1执行结束时与test1的AO断开，但是因为return了函数test2，test2被全局变量test3所接收，test2的作用域还连着test1的AO，所以test1的AO还不能销毁。</p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/08/06/aRuKit.png" alt="aRuKit.png"></p><p>test3执行，test2的作用链上增加了自己的AO，当打印a的时候，test2在自己的AO上没有找到，于是向下层的test1的AO中查找，找到a后输出1。</p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/08/06/aRunII.png" alt="aRunII.png"></p><p>test3执行结束后，test2自己的AO被销毁，但test1的AO仍然存在且被test2紧紧攥着。当test3再次执行时，test2又会重新创建自己的AO，查找test1AO中的a并输出。</p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/08/06/aRuMJP.png" alt="aRuMJP.png"></p><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p>函数声明在<strong>定义</strong>的时候会取<strong>上级作用域环境</strong>，在执行时的前一刻（<strong>预编译</strong>环节）会<strong>生成自己的AO</strong>，执行<strong>结束</strong>时回到之前<strong>定义时</strong>的状态，即<strong>删除自己的AO</strong>，若有执行函数有下级函数，那么下级函数的[[scope]]会被销毁，因为被删除的AO中储存了下级函数。</p><p>当<strong>内部</strong>函数被返回到<strong>外部并保存</strong>时，一定会产生<strong>闭包</strong>，闭包会使得原来的作用域链<strong>不被释放</strong>，从而一直保存着数据。<strong>过度</strong>的闭包可能会导致<strong>内存泄漏或者加载过慢</strong>。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="闭包" scheme="http://yoursite.com/categories/%E9%97%AD%E5%8C%85/"/>
    
    
      <category term="作用域" scheme="http://yoursite.com/tags/%E4%BD%9C%E7%94%A8%E5%9F%9F/"/>
    
      <category term="作用域链" scheme="http://yoursite.com/tags/%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE/"/>
    
      <category term="闭包" scheme="http://yoursite.com/tags/%E9%97%AD%E5%8C%85/"/>
    
  </entry>
  
  <entry>
    <title>11-JavaScript预编译过程</title>
    <link href="http://yoursite.com/2020/08/03/20-JavaScript%E9%A2%84%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B/"/>
    <id>http://yoursite.com/2020/08/03/20-JavaScript%E9%A2%84%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B/</id>
    <published>2020-08-03T06:43:24.000Z</published>
    <updated>2020-08-06T15:13:29.202Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>预编译是执行函数之前的过程</p><h3 id="GO全局的执行期上下文"><a href="#GO全局的执行期上下文" class="headerlink" title="GO全局的执行期上下文"></a>GO全局的执行期上下文</h3><ol><li>寻找变量声明</li><li>寻找函数声明</li><li>执行 </li></ol><h3 id="AO函数的执行器上下文"><a href="#AO函数的执行器上下文" class="headerlink" title="AO函数的执行器上下文"></a>AO函数的执行器上下文</h3><ol><li>寻找形参和变量声明</li><li>实参值赋值给形参</li><li>寻找函数声明，赋值</li><li>执行</li></ol><p><strong>在函数内部未声明的变量会提升到全局作用域，即暗示全局作用域</strong></p><h4 id="例题一"><a href="#例题一" class="headerlink" title="例题一"></a>例题一</h4><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/08/05/a6R61K.png" alt=""></p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/08/05/a6ROBQ.png" alt=""></p><h4 id="例题二"><a href="#例题二" class="headerlink" title="例题二"></a>例题二</h4><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/08/06/a6Rzhq.png" alt=""></p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/08/06/a6W93V.png" alt=""></p><h4 id="例题三"><a href="#例题三" class="headerlink" title="例题三"></a>例题三</h4><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/08/06/a6WVE9.png" alt=""></p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/08/06/a6WAHJ.png" alt=""></p><h4 id="例题四"><a href="#例题四" class="headerlink" title="例题四"></a>例题四</h4><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/08/06/a6Wn9x.png" alt=""></p><h4 id="例题五"><a href="#例题五" class="headerlink" title="例题五"></a>例题五</h4><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/08/06/a6WJUA.png" alt=""></p><h4 id="例题六"><a href="#例题六" class="headerlink" title="例题六"></a>例题六</h4><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/08/06/a6WGEd.png" alt=""></p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/08/06/a6W3HH.png" alt=""></p><h4 id="例题七"><a href="#例题七" class="headerlink" title="例题七"></a>例题七</h4><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/08/06/a6WBDg.png" alt=""></p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/08/06/a6Wdv8.png" alt=""></p><h4 id="例题八"><a href="#例题八" class="headerlink" title="例题八"></a>例题八</h4><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/08/06/a6W0KS.png" alt=""></p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/08/06/a6Wagf.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="预编译" scheme="http://yoursite.com/categories/%E9%A2%84%E7%BC%96%E8%AF%91/"/>
    
    
      <category term="预编译" scheme="http://yoursite.com/tags/%E9%A2%84%E7%BC%96%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title>10-Javascript显式和隐式类型转换</title>
    <link href="http://yoursite.com/2020/08/02/19-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E8%BD%AC%E6%8D%A2/"/>
    <id>http://yoursite.com/2020/08/02/19-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E8%BD%AC%E6%8D%A2/</id>
    <published>2020-08-02T04:23:43.000Z</published>
    <updated>2020-08-04T14:39:29.142Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="显式类型转换"><a href="#显式类型转换" class="headerlink" title="显式类型转换"></a>显式类型转换</h2><h3 id="1-Number"><a href="#1-Number" class="headerlink" title="1.Number()"></a>1.Number()</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Number(true&#x2F;false)  &#x2F;&#x2F; 1&#x2F;0</span><br><span class="line">Number(null)   &#x2F;&#x2F; 0</span><br><span class="line">Number(undefined)&#x2F;&#x2F; NaN</span><br><span class="line">Number(&#39;a&#39;)   &#x2F;&#x2F; NaN</span><br><span class="line">Number(&#39;1a&#39;) &#x2F;&#x2F; NaN</span><br></pre></td></tr></table></figure><h2 id="2-praseInt"><a href="#2-praseInt" class="headerlink" title="2.praseInt()"></a>2.praseInt()</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">praseInt(true&#x2F;false) &#x2F;&#x2F; NaN</span><br><span class="line">praseInt(null)  &#x2F;&#x2F; 0</span><br><span class="line">praseInt(undefined)  &#x2F;&#x2F; NaN</span><br><span class="line">praseInt(NaN) &#x2F;&#x2F; NaN</span><br><span class="line">praseInt(&#39;abc123&#39;)   &#x2F;&#x2F; NaN</span><br><span class="line">praseInt(&#39;123abc&#39;)   &#x2F;&#x2F; 123</span><br></pre></td></tr></table></figure><h2 id="3-Boolean"><a href="#3-Boolean" class="headerlink" title="3.Boolean()"></a>3.Boolean()</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Boolean(1&#x2F;0)&#x2F;&#x2F; ture&#x2F;false</span><br><span class="line">Boolean(null)&#x2F;&#x2F; false</span><br><span class="line">Boolean(undefined)  &#x2F;&#x2F; false</span><br><span class="line">Boolean(NaN)&#x2F;&#x2F; false</span><br><span class="line">Boolean(&quot;&quot;)&#x2F;&#x2F; false</span><br><span class="line">Boolean(0)&#x2F;&#x2F; false</span><br><span class="line">Boolean(false)&#x2F;&#x2F; false</span><br><span class="line">其他都是true</span><br></pre></td></tr></table></figure><p><strong>注意</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">undefined.toString()和null.toString()都会报错</span><br></pre></td></tr></table></figure><h2 id="隐式类型转换"><a href="#隐式类型转换" class="headerlink" title="隐式类型转换"></a>隐式类型转换</h2><h4 id="隐式转成number"><a href="#隐式转成number" class="headerlink" title="隐式转成number"></a>隐式转成number</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">+;-;*;&#x2F;;%;</span><br><span class="line">++;--;&#x3D;&#x3D;;!&#x3D;;</span><br><span class="line">&gt;;&lt;;&lt;&#x3D;;&gt;&#x3D;;</span><br><span class="line">补充：undefined&#x3D;&#x3D;null</span><br></pre></td></tr></table></figure><h3 id="isNaN"><a href="#isNaN" class="headerlink" title="isNaN()"></a>isNaN()</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">isNaN(NaN)&#x2F;&#x2F;true</span><br><span class="line">isNaN(123)&#x2F;&#x2F;false</span><br><span class="line">isNaN(&#39;123&#39;)&#x2F;&#x2F;false</span><br><span class="line">isNaN(undefined)&#x2F;&#x2F;true</span><br><span class="line">isNaN(null)&#x2F;&#x2F;false</span><br><span class="line">isNaN(&#39;a&#39;)&#x2F;&#x2F;true</span><br><span class="line">number &#x3D;&gt;isNaN &#x3D;&gt;boo</span><br></pre></td></tr></table></figure><h2 id="typeof-判断类型"><a href="#typeof-判断类型" class="headerlink" title="typeof()判断类型"></a>typeof()判断类型</h2><ol><li>123 =&gt; number</li><li>‘123’ =&gt; string</li><li>{123},[123],null =&gt;object</li><li>function(){} =&gt;function</li><li>undefined</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">typeof(1-&#39;1&#39;) &#x2F;&#x2F; number</span><br><span class="line">typeof(&#39;1&#39;-&#39;1&#39;)&#x2F;&#x2F;number</span><br><span class="line">typeof(1)&#x2F;&#x2F;number</span><br><span class="line">typeof(typeof(1))&#x2F;&#x2F;string</span><br><span class="line">typeof(undefined)&#x2F;&#x2F;undefined</span><br><span class="line">typeof(typeof(undefined))&#x2F;&#x2F;string</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="数据类型" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    
    
      <category term="数据类型" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>vue解决跨域问题</title>
    <link href="http://yoursite.com/2020/08/01/18-vue%E8%A7%A3%E5%86%B3%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2020/08/01/18-vue%E8%A7%A3%E5%86%B3%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98/</id>
    <published>2020-08-01T08:14:35.000Z</published>
    <updated>2020-08-03T12:29:46.058Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><strong>一.什么是跨域</strong></p><p>跨域问题的出现是因为浏览器的同源策略问题，所谓同源:就是两个页面具有相同的协议（protocol），主机（host）和端口号（port），它是浏览器最核心也是最基本的功能，如果没有同源策略我们的浏览器将会十分的不安全，随时都可能受到攻击。</p><p>当我们请求一个接口的时候，出现如：Access-Control-Allow-Origin 字眼的时候说明请求跨域了</p><p><img src= "/img/loading.gif" data-src="https://img2018.cnblogs.com/i-beta/1649717/202002/1649717-20200227142258131-1409861315.png" alt=""></p><p><strong>二.如何解决跨域问题</strong></p><p>在vue项目根目录下找到vue.config.js文件（如果没有该文件则自己创建），在proxy中设置跨域</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">devServer: &#123;</span><br><span class="line">    proxy: &#123;  &#x2F;&#x2F;配置跨域</span><br><span class="line">      &#39;&#x2F;api&#39;: &#123;</span><br><span class="line">        target: &#39;http:&#x2F;&#x2F;121.121.67.254:8185&#x2F;&#39;,  &#x2F;&#x2F;这里后台的地址模拟的;应该填写你们真实的后台接口</span><br><span class="line">        changOrigin: true,  &#x2F;&#x2F;允许跨域</span><br><span class="line">        pathRewrite: &#123;</span><br><span class="line">          &#x2F;* 重写路径，当我们在浏览器中看到请求的地址为：http:&#x2F;&#x2F;localhost:8080&#x2F;api&#x2F;core&#x2F;getData&#x2F;userInfo 时</span><br><span class="line">            实际上访问的地址是：http:&#x2F;&#x2F;121.121.67.254:8185&#x2F;core&#x2F;getData&#x2F;userInfo,因为重写了 &#x2F;api</span><br><span class="line">           *&#x2F;</span><br><span class="line">          &#39;^&#x2F;api&#39;: &#39;&#39; </span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure><p><strong>在vue中使用proxy进行跨域的原理是：将域名发送给本地的服务器（启动vue项目的服务,loclahost:8080），再由本地的服务器去请求真正的服务器。</strong></p><p>以下是我在开发vue项目中实现跨域的步骤：</p><p>　　1.在proxy中设置要访问的地址，并重写/api为空的字符串，因为我们真正请求的地址是没有带/api，这个重写很重要!!!</p><p>　　<img src= "/img/loading.gif" data-src="https://img2018.cnblogs.com/i-beta/1649717/202002/1649717-20200227144905470-1085262547.png" alt="img"></p><p> 　2.在创建axios实例的时候将baseURL设置为/api ,这时候我们的跨域就已经完成了。</p><p>　　<img src= "/img/loading.gif" data-src="https://img2018.cnblogs.com/i-beta/1649717/202002/1649717-20200227145106938-1311841373.png" alt="img"></p><p> 　3. 假如请求的真正地址为：<a href="http://121.121.67.254:8185/core/getdata/userInfo,但我们在浏览器上会看到是这样的：" target="_blank" rel="noopener">http://121.121.67.254:8185/core/getdata/userInfo,但我们在浏览器上会看到是这样的：</a> <a href="http://localhost:8080/api/core/getData/userInfo" target="_blank" rel="noopener">http://localhost:8080/api/core/getData/userInfo</a> ,多了个/api，但并不影响我们请求数据。</p><p>　　<img src= "/img/loading.gif" data-src="https://img2018.cnblogs.com/i-beta/1649717/202002/1649717-20200227151147818-885350634.png" alt="img"></p><p><strong>注意：当修改了vue.config.js中的内容后，一定要重新启动服务yarn start 或者npm run dev之后，修改的内容才会生效</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="VUE" scheme="http://yoursite.com/categories/VUE/"/>
    
      <category term="跨域" scheme="http://yoursite.com/categories/VUE/%E8%B7%A8%E5%9F%9F/"/>
    
    
      <category term="VUE" scheme="http://yoursite.com/tags/VUE/"/>
    
      <category term="跨域" scheme="http://yoursite.com/tags/%E8%B7%A8%E5%9F%9F/"/>
    
  </entry>
  
  <entry>
    <title>实现一个sleep函数</title>
    <link href="http://yoursite.com/2020/07/29/17-%E5%AE%9E%E7%8E%B0sleep%E5%87%BD%E6%95%B0/"/>
    <id>http://yoursite.com/2020/07/29/17-%E5%AE%9E%E7%8E%B0sleep%E5%87%BD%E6%95%B0/</id>
    <published>2020-07-29T08:12:32.000Z</published>
    <updated>2020-08-01T13:23:52.419Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="实现一个sleep函数，比如sleep-1000-意味着等待1000毫秒，可以从Promise、Generator、Async-Await等角度实现。"><a href="#实现一个sleep函数，比如sleep-1000-意味着等待1000毫秒，可以从Promise、Generator、Async-Await等角度实现。" class="headerlink" title="实现一个sleep函数，比如sleep(1000)意味着等待1000毫秒，可以从Promise、Generator、Async/Await等角度实现。"></a>实现一个sleep函数，比如sleep(1000)意味着等待1000毫秒，可以从Promise、Generator、Async/Await等角度实现。</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function sleep(ms) &#123;</span><br><span class="line">return new Promise(resolve&#x3D;&gt;&#123;</span><br><span class="line"> setInterval(resolve,ms)</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">(async()&#x3D;&gt;&#123;</span><br><span class="line">console.log(111)</span><br><span class="line">await sleep(2000)</span><br><span class="line">console.log(222)</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="E6" scheme="http://yoursite.com/categories/E6/"/>
    
      <category term="Promise" scheme="http://yoursite.com/categories/E6/Promise/"/>
    
      <category term="async/await" scheme="http://yoursite.com/categories/E6/Promise/async-await/"/>
    
    
      <category term="Promise" scheme="http://yoursite.com/tags/Promise/"/>
    
      <category term="E6" scheme="http://yoursite.com/tags/E6/"/>
    
      <category term="async/await" scheme="http://yoursite.com/tags/async-await/"/>
    
  </entry>
  
  <entry>
    <title>判断输出代码的执行结果并解释为什么</title>
    <link href="http://yoursite.com/2020/07/28/15-%E5%88%A4%E6%96%AD%E8%BE%93%E5%87%BA%E4%BB%A3%E7%A0%81%E7%9A%84%E6%89%A7%E8%A1%8C%E7%BB%93%E6%9E%9C%E5%B9%B6%E8%A7%A3%E9%87%8A%E4%B8%BA%E4%BB%80%E4%B9%88/"/>
    <id>http://yoursite.com/2020/07/28/15-%E5%88%A4%E6%96%AD%E8%BE%93%E5%87%BA%E4%BB%A3%E7%A0%81%E7%9A%84%E6%89%A7%E8%A1%8C%E7%BB%93%E6%9E%9C%E5%B9%B6%E8%A7%A3%E9%87%8A%E4%B8%BA%E4%BB%80%E4%B9%88/</id>
    <published>2020-07-28T05:54:14.000Z</published>
    <updated>2020-08-01T12:54:06.981Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var a &#x3D; &#123;n:1&#125;;</span><br><span class="line">var b &#x3D; a ;</span><br><span class="line">a.x &#x3D; a &#x3D; &#123;n : 2&#125;</span><br><span class="line"></span><br><span class="line">console.log(a.x)</span><br><span class="line">console.log(b.x)</span><br></pre></td></tr></table></figure><h5 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h5><p>这道题的关键知识点是连等，首先我们要知道连等开始之前程序会把所有的引用都保存下来，连等的过程中，这些值是保持不变的，等到整个连等都完事了，再一块儿变。</p><p>这是我画的图解：</p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/08/01/a3zXWD.png" alt=""></p><h5 id="输出结果："><a href="#输出结果：" class="headerlink" title="输出结果："></a>输出结果：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">console.log(a.x)  &#x2F;&#x2F; undefined</span><br><span class="line">console.log(b.x)  &#x2F;&#x2F; x:&#123;n:2&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="连等" scheme="http://yoursite.com/categories/%E8%BF%9E%E7%AD%89/"/>
    
    
      <category term="连等" scheme="http://yoursite.com/tags/%E8%BF%9E%E7%AD%89/"/>
    
  </entry>
  
  <entry>
    <title>09-对TCP三次握手和四次挥手的理解</title>
    <link href="http://yoursite.com/2020/07/28/16-%E5%AF%B9TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%92%8C%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%E7%9A%84%E7%90%86%E8%A7%A3/"/>
    <id>http://yoursite.com/2020/07/28/16-%E5%AF%B9TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%92%8C%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%E7%9A%84%E7%90%86%E8%A7%A3/</id>
    <published>2020-07-28T05:54:14.000Z</published>
    <updated>2020-08-01T13:24:51.533Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="建立连接-3-way-handshake"><a href="#建立连接-3-way-handshake" class="headerlink" title="建立连接 3-way handshake"></a>建立连接 3-way handshake</h2><p>客户端给服务器发送SYN（同步序列编号n）询问能否建立连接，服务器返回ACK（确认字符）+SYN（同步序列n+1），客户端再返回ACK消息响应，这样客户端就和服务器就建立了连接。</p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/08/01/a81x1g.png" alt=""></p><h2 id="主动断开连接-4-times-close"><a href="#主动断开连接-4-times-close" class="headerlink" title="主动断开连接 4-times close"></a>主动断开连接 4-times close</h2><p>客户端向服务器发送FIN:1,SEQ:n询问是否断开连接，服务端第一次回应ACK:n+1表示收到断开请求,第二次再返回FIN:1和SEQ：m告诉客服端已经准备好断开连接了，客户端最后返回ACK:m+1响应收到并断开连接。</p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/08/01/a81zcQ.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="HTTP" scheme="http://yoursite.com/categories/HTTP/"/>
    
    
      <category term="HTTP" scheme="http://yoursite.com/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>08-HTTP缓存控制</title>
    <link href="http://yoursite.com/2020/07/27/14-HTTP%E7%BC%93%E5%AD%98%E6%8E%A7%E5%88%B6/"/>
    <id>http://yoursite.com/2020/07/27/14-HTTP%E7%BC%93%E5%AD%98%E6%8E%A7%E5%88%B6/</id>
    <published>2020-07-27T11:42:36.000Z</published>
    <updated>2020-07-27T15:02:01.377Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>HTTP缓存作用范围：从浏览器第一次请求到第二次浏览器响应，至少需要两次http请求。</p><p>HTTP缓存能够帮助服务器提升并发性能，很多资源不需要重复请求服务器，通过浏览器缓存就能获取到。</p><p>浏览器缓存分为：<strong>强缓存</strong>和<strong>协商缓存</strong></p><h4 id="强缓存"><a href="#强缓存" class="headerlink" title="强缓存"></a>强缓存</h4><p>不用发送请求到服务器就能获取到缓存文件</p><p><strong>如何判断强缓存</strong>：状态码为200OK，from cache</p><p>强缓存是利用http的返回头中的Expires和cache-Contrl来控制的，用来表示资源的缓存时间</p><h5 id="为什么有了Expires还要有cache-Contrl？"><a href="#为什么有了Expires还要有cache-Contrl？" class="headerlink" title="为什么有了Expires还要有cache-Contrl？"></a>为什么有了Expires还要有cache-Contrl？</h5><p>因为Expires是绝对时间，存在服务器与客户端时间不同步的问题。而cache-Contrl是相对时间，是相对于第一次请求的时间计算的。</p><p>cache-Contrl:max-age=9999</p><h4 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h4><p>发送请求到服务器，服务器判断本地缓存是否更新，若可以使用，服务器则不返回资源信息，浏览器继续从缓存中获取资源。</p><p><strong>判断协商缓存</strong>：状态码304 利用http返回头中的last-modify(第一次请求服务器返回)/if-modify-since(第二次浏览器发送请求)或Etag/if-none-match(返回唯一的校验码) </p><h5 id="为什么有了lats-modify还要有Etag？"><a href="#为什么有了lats-modify还要有Etag？" class="headerlink" title="为什么有了lats-modify还要有Etag？"></a>为什么有了lats-modify还要有Etag？</h5><p>因为last-modify的时间精确到秒，若是比秒更短的时间则无法判断，存在时间精度问题。而Etag返回的是唯一的校验码，每次更新缓存就会改变。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="HTTP" scheme="http://yoursite.com/categories/HTTP/"/>
    
    
      <category term="HTTP" scheme="http://yoursite.com/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>07-HTTP 基本概念</title>
    <link href="http://yoursite.com/2020/07/26/13-HTTP%20%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"/>
    <id>http://yoursite.com/2020/07/26/13-HTTP%20%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</id>
    <published>2020-07-26T12:12:45.000Z</published>
    <updated>2020-07-26T14:02:17.899Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="HTTP-是什么？描述一下"><a href="#HTTP-是什么？描述一下" class="headerlink" title="HTTP 是什么？描述一下"></a>HTTP 是什么？描述一下</h2><ul><li>HTTP 是超文本传输协议，也就是HyperText Transfer Protocol。</li></ul><h2 id="能否详细解释「超文本传输协议」？"><a href="#能否详细解释「超文本传输协议」？" class="headerlink" title="能否详细解释「超文本传输协议」？"></a>能否详细解释「超文本传输协议」？</h2><ul><li><p>HTTP的名字「超文本协议传输」，它可以拆成三个部分：</p><ul><li><p>超文本</p></li><li><p>传输</p></li><li><p>协议</p></li></ul></li><li><p>HTTP 是一个在计算机世界里专门在「两点」之间「传输」文字、图片、音频、视频等「超文本」数据的「约定和规范」。</p></li></ul><ul><li>那「HTTP 是用于从互联网服务器传输超文本到本地浏览器的协议HTTP」 ，这种说法正确吗？<ul><li>这种说法是不正确的。因为也可以是「服务器&lt; – &gt;服务器」，所以采用两点之间的描述会更准确。</li></ul></li></ul><h2 id="HTTP-常见的状态码，有哪些？"><a href="#HTTP-常见的状态码，有哪些？" class="headerlink" title="HTTP 常见的状态码，有哪些？"></a>HTTP 常见的状态码，有哪些？</h2><ul><li><p>1xx</p><ul><li>1xx 类状态码属于提示信息，是协议处理中的一种中间状态，实际用到的比较少。</li></ul></li><li><p>2xx</p><ul><li><p>2xx 类状态码表示服务器成功处理了客户端的请求，也是我们最愿意看到的状态。</p></li><li><p>「200 OK」是最常见的成功状态码，表示一切正常。如果是非 HEAD 请求，服务器返回的响应头都会有 body 数据。</p></li><li><p>「204 No Content」也是常见的成功状态码，与 200 OK 基本相同，但响应头没有 body 数据。</p></li><li><p>「206 Partial Content」是应用于 HTTP 分块下载或断电续传，表示响应返回的 body 数据并不是资源的全部，而是其中的一部分，也是服务器处理成功的状态。</p></li></ul></li><li><p>3xx</p><ul><li><p>3xx 类状态码表示客户端请求的资源发送了变动，需要客户端用新的 URL 重新发送请求获取资源，也就是重定向。</p></li><li><p>「301 Moved Permanently」表示永久重定向，说明请求的资源已经不存在了，需改用新的 URL 再次访问。</p></li><li><p>「302 Moved Permanently」表示临时重定向，说明请求的资源还在，但暂时需要用另一个 URL 来访问。</p></li><li><p>301 和 302 都会在响应头里使用字段 Location，指明后续要跳转的 URL，浏览器会自动重定向新的 URL。</p></li><li><p>「304 Not Modified」不具有跳转的含义，表示资源未修改，重定向已存在的缓冲文件，也称缓存重定向，用于缓存控制。</p></li></ul></li><li><p>4xx</p><ul><li><p>4xx 类状态码表示客户端发送的报文有误，服务器无法处理，也就是错误码的含义。</p></li><li><p>「400 Bad Request」表示客户端请求的报文有错误，但只是个笼统的错误。</p></li><li><p>「403 Forbidden」表示服务器禁止访问资源，并不是客户端的请求出错。</p></li><li><p>「404 Not Found」表示请求的资源在服务器上不存在或未找到，所以无法提供给客户端。</p></li></ul></li><li><p>5xx</p><p><img src= "/img/loading.gif" data-src="https://api2.mubu.com/v3/document_image/28295742-106c-437f-89ae-2a75c243ad8b-3807603.jpg" alt=""></p><ul><li><p>5xx 类状态码表示客户端请求报文正确，但是服务器处理时内部发生了错误，属于服务器端的错误码。</p></li><li><p>「500 Internal Server Error」与 400 类型，是个笼统通用的错误码，服务器发生了什么错误，我们并不知道。</p></li><li><p>「501 Not Implemented」表示客户端请求的功能还不支持，类似“即将开业，敬请期待”的意思。</p></li><li><p>「502 Bad Gateway」通常是服务器作为网关或代理时返回的错误码，表示服务器自身工作正常，访问后端服务器发生了错误。</p></li><li><p>「503 Service Unavailable」表示服务器当前很忙，暂时无法响应服务器，类似“网络服务正忙，请稍后重试”的意思。</p></li></ul></li></ul><h2 id="http-常见字段有哪些？"><a href="#http-常见字段有哪些？" class="headerlink" title="http 常见字段有哪些？"></a>http 常见字段有哪些？</h2><ul><li><p>Host</p><ul><li><p>客户端发送请求时，用来指定服务器的域名。<img src= "/img/loading.gif" data-src="https://api2.mubu.com/v3/document_image/fb86d6fd-e6bd-41cf-aece-fed0037dcf81-3807603.jpg" alt="img"></p></li><li><p>Host: <a href="http://www.A.com" target="_blank" rel="noopener">http://www.A.com</a></p></li><li><p>有了 Host 字段，就可以将请求发往「同一台」服务器上的不同网站。</p></li></ul></li><li><p>Content-Length 字段</p><ul><li><p>服务器在返回数据时，会有 Content-Length 字段，表明本次回应的数据长度。<img src= "/img/loading.gif" data-src="https://api2.mubu.com/v3/document_image/2ca4f141-26f2-48bf-a4e7-6e718db6b056-3807603.jpg" alt="img"></p></li><li><p>Content-Length: 1000</p></li><li><p>如上面则是告诉浏览器，本次服务器回应的数据长度是 1000 个字节，后面的字节就属于下一个回应了。</p></li></ul></li><li><p>Connection 字段</p><ul><li><p>Connection 字段最常用于客户端要求服务器使用 TCP 持久连接，以便其他请求复用。<img src= "/img/loading.gif" data-src="https://api2.mubu.com/v3/document_image/e76e6254-5918-4759-a25e-6b0f33ca9968-3807603.jpg" alt="img"></p></li><li><p>HTTP/1.1 版本的默认连接都是持久连接，但为了兼容老版本的 HTTP，需要指定 Connection 首部字段的值为 Keep-Alive。</p></li><li><p>Connection: keep-alive</p></li><li><p>一个可以复用的 TCP 连接就建立了，直到客户端或服务器主动关闭连接。但是，这不是标准字段。</p></li></ul></li><li><p>Content-Type 字段</p><ul><li><p>Content-Type 字段用于服务器回应时，告诉客户端，本次数据是什么格式。<img src= "/img/loading.gif" data-src="https://api2.mubu.com/v3/document_image/70955d3f-0d65-4e0c-afe7-dbbdbcc4fe59-3807603.jpg" alt="img"></p></li><li><p>Content-Type: text/html; charset=utf-8</p></li><li><p>上面的类型表明，发送的是网页，而且编码是UTF-8。</p></li><li><p>客户端请求的时候，可以使用 Accept 字段声明自己可以接受哪些数据格式。</p></li><li><p>Accept: <em>/</em></p></li><li><p>上面代码中，客户端声明自己可以接受任何格式的数据。</p></li></ul></li><li><p>Content-Encoding 字段</p><ul><li><p>Content-Encoding 字段说明数据的压缩方法。表示服务器返回的数据使用了什么压缩格式<img src= "/img/loading.gif" data-src="https://api2.mubu.com/v3/document_image/e55a7e13-db1f-4307-9b91-39c430d196cd-3807603.jpg" alt="img"></p></li><li><p>Content-Encoding: gzip</p></li><li><p>上面表示服务器返回的数据采用了 gzip 方式压缩，告知客户端需要用此方式解压。</p></li><li><p>客户端在请求时，用 Accept-Encoding 字段说明自己可以接受哪些压缩方法。</p></li><li><p>Accept-Encoding: gzip, deflate</p></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="HTTP" scheme="http://yoursite.com/categories/HTTP/"/>
    
    
      <category term="HTTP" scheme="http://yoursite.com/tags/HTTP/"/>
    
      <category term="状态码" scheme="http://yoursite.com/tags/%E7%8A%B6%E6%80%81%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>06-正则表达式知识整理</title>
    <link href="http://yoursite.com/2020/07/24/11-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>http://yoursite.com/2020/07/24/11-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</id>
    <published>2020-07-24T14:36:56.000Z</published>
    <updated>2020-07-24T15:58:10.958Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><strong>正则</strong>：是一个用来处理字符串的规则，由元字符和修字符组成</p><ol><li>正则只能用来处理字符串</li><li>处理一般包括两个方面：<ol><li>验证当前字符出是否符合某个规则 “正则匹配”</li><li>把一个字符串中符合规则的字符获取到 “正则捕获”</li></ol></li></ol><p><strong>创建正则的两种方式：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let reg &#x3D; new RegExp(&quot;^\\d+$&quot;,&quot;g&quot;); &#x2F;&#x2F;构造函数</span><br><span class="line">let reg &#x3D; &#x2F;^\d+$&#x2F;g;  &#x2F;&#x2F;字面量方式</span><br></pre></td></tr></table></figure><p><strong>有效数字</strong></p><p>1.正数 负数 零 小数 正数</p><p>let reg = /^[+-]?(\d|([1-9]\d+))(\ .\d+)?$/;</p><p><strong>手机号码</strong></p><p>1.十一位 以1开头 </p><p>let reg = /^1/d{10}$/</p><p><strong>中文姓名</strong></p><p>1.中文汉字   [\u4E00-\u9FA5]</p><p>let reg = /^ [\u4E00-\u9FA5]{2,}(·[\u4E00-\u9FA5]{2,})?$/</p><p><strong>邮箱</strong></p><p>let reg = /^/w+([.-]/w+)*@[a-zA-Z0-9] +([-.] [a-zA-Z0-9]+) *(/. [a-zA-Z0-9]+)]$/</p><p><strong>正则捕获</strong>：把一个字符串中和正则匹配的部分获取到</p><p>【正则】 exec test</p><p>【字符串】replace split match</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let str &#x3D; &#39;dnfei123&#39;</span><br><span class="line">let reg &#x3D; &#x2F;\d+&#x2F;</span><br><span class="line">console.log(reg.test(str)) &#x2F;&#x2F;true or false</span><br><span class="line">console.log(reg.exec(str)) &#x2F;&#x2F;null or array</span><br></pre></td></tr></table></figure><h3 id="基于EXEC可以实现正则的捕获"><a href="#基于EXEC可以实现正则的捕获" class="headerlink" title="基于EXEC可以实现正则的捕获"></a>基于EXEC可以实现正则的捕获</h3><ol><li><p>如果当前正则和字符串不匹配，捕获的结果是null</p></li><li><p>如果匹配，捕获的结果是一个数组</p><p>​    0：大正则捕获的内容</p><p>​    index：正则捕获的起使索引</p><p>​    input：原始操作的字符串</p></li><li><p>执行一次exec只能捕获到第一个和正则匹配的内容，其余匹配内容没有捕获到，执行多次也只能捕获第一个匹配的内容</p><p>==》正则的捕获有<strong>懒惰性</strong>：只能捕获到第一个匹配的内容，剩余的默认捕获不到</p><h3 id="自己封装一个方法能够一次捕获全部匹配结果"><a href="#自己封装一个方法能够一次捕获全部匹配结果" class="headerlink" title="自己封装一个方法能够一次捕获全部匹配结果"></a>自己封装一个方法能够一次捕获全部匹配结果</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">RegExp.prototype.myExecall &#x3D; function(str) &#123;</span><br><span class="line">if(!this.glabal)&#123;</span><br><span class="line">return this.exec(str);</span><br><span class="line">&#125;</span><br><span class="line">let result &#x3D; [],</span><br><span class="line">valAry &#x3D; this.exec(str);</span><br><span class="line">while(valAry) &#123; </span><br><span class="line">result.push(valAry[0]) &#x3D;&gt;把每次正则捕获到的结果的第一项存储到容器中</span><br><span class="line">valAry &#x3D; this.exec(str);</span><br><span class="line">&#125;</span><br><span class="line">return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="分组捕获-exec与match的局限性"><a href="#分组捕获-exec与match的局限性" class="headerlink" title="分组捕获-exec与match的局限性"></a>分组捕获-exec与match的局限性</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let str &#x3D; &#39;fheufhr&#123;2020&#125;fjirj&#123;2021&#125;&#39;,</span><br><span class="line">reg &#x3D; &#x2F;\&#123;(\d+)\&#125;&#x2F;g  &#x2F;&#x2F;&#x3D;&gt;大括号有特殊含义</span><br><span class="line">&#x2F;&#x2F;console.log(reg.exec(str))  &#x3D;&gt;[&#39;&#123;2020&#125;&#39;,&#39;2020&#39;]</span><br></pre></td></tr></table></figure><p>在正则捕获的时候，如果正则中存在分组，捕获的时候不仅仅把大正则匹配到的字符捕获到（数组第一项），也会把小分组匹配的内容也单独抽取出来（数组第二项开始就是小分组捕获的内容） =》<strong>分组捕获</strong> ，而/\ {(?:\d+)\ }/g中的<strong>?:</strong>可以用来阻止分组捕获内容的“<strong>只匹配不捕获</strong>”</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(str.match(reg));&#x2F;&#x2F;&#x3D;&gt;[&quot;&#123;2020&#125;&quot;,&quot;&#123;2021&#125;&quot;]</span><br></pre></td></tr></table></figure><p>match方法也有自己的局限性，在正则设置了g的情况下，基于match捕获的内容只有大正则匹配的，小分组的内容没有单独抽取出来（不设置g的情况下和执行exec一样）</p><h3 id="test与exec"><a href="#test与exec" class="headerlink" title="test与exec"></a>test与exec</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let str &#x3D; &#39;fheufhr2020fjirj2021&#39;,</span><br><span class="line">reg &#x3D; &#x2F;\d+&#x2F;g  </span><br><span class="line">console.log(reg.test(str))  &#x3D;&gt;true</span><br><span class="line">console.log(reg.lastIndex)  &#x3D;&gt;7 &#x2F;&#x2F;基于test进行匹配的时候，如果设置了g，test匹配也相当于捕获，修改了lastindex的值</span><br><span class="line">console.log(reg.exec(str))  &#x3D;&gt;[&#39;2021&#39;]</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let str &#x3D; &#39;fheufhr2020fjirj2021&#39;,</span><br><span class="line">reg &#x3D; &#x2F;\d+&#x2F;g  </span><br><span class="line">console.log(reg.exec(str))  &#x3D;&gt;[&#39;2020&#39;] &#x2F;&#x2F;把reg.lastindex的值修改了</span><br><span class="line">console.log(reg.exec(str))  &#x3D;&gt;[&#39;2021&#39;] &#x2F;&#x2F;虽然捕获的不是同一个字符串，但是正则是同一个，上一次正则处理的时候修改了lastindex，也会对下一次匹配的新的字符串产生影响</span><br></pre></td></tr></table></figure><h3 id="时间字符串格式化"><a href="#时间字符串格式化" class="headerlink" title="时间字符串格式化"></a>时间字符串格式化</h3><p>”2020/07/20 20:13:23“  =&gt;”07-20 20:13”</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let str &#x3D; &quot;2020&#x2F;07&#x2F;20 20:13:23&quot;,</span><br><span class="line">arr &#x3D; str.split(&#x2F;(?:\&#x2F;| |:)&#x2F;g)</span><br><span class="line">console.log(arr) &#x3D;&gt; [&quot;2020&quot;, &quot;07&quot;, &quot;20&quot;, &quot;20&quot;, &quot;13&quot;, &quot;23&quot;]</span><br><span class="line">let [,mouth,day,hours,minutes] &#x3D; arr,</span><br><span class="line">result &#x3D; &#96;$&#123;mouth&#125;-$&#123;day&#125; $&#123;hours&#125;:$&#123;minutes&#125;&#96;</span><br><span class="line">&#x3D;&gt;&quot;07-20 20:13&quot;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">let str &#x3D; &quot;2020&#x2F;7&#x2F;20 20:13:23&quot;</span><br><span class="line">&#x2F;&#x2F;获取时间字符串中所有的数字</span><br><span class="line">let arr &#x3D; str.match(&#x2F;\d+&#x2F;g).map(item&#x3D;&gt;&#123;</span><br><span class="line">&#x2F;&#x2F;&#x3D;&gt;map相对于foreach来说多了返回值，函数中return的是啥，就把当前数组中迭代的这一项替换成啥</span><br><span class="line">return item&lt;10?&#39;0&#39;+item :item; </span><br><span class="line">&#125;)</span><br><span class="line">&#x2F;&#x2F;指定最后想要的时间格式，基于这个数组的内容，帮你拼接好即可</span><br><span class="line">let template &#x3D; &#39;&#123;0&#125;年&#123;1&#125;月&#123;2&#125;日 &#123;3&#125;时&#123;4&#125;分&#123;5&#125;秒&#39;</span><br><span class="line">&#x2F;&#x2F;&#x3D;&gt;&#123;0&#125; &#x2F; 0 &#x3D;&gt;&#39;2020&#39; arr[0]</span><br><span class="line">&#x2F;&#x2F;&#x3D;&gt;&#123;1&#125; &#x2F; 1 &#x3D;&gt;&#39;07&#39; arr[1]...</span><br><span class="line">template &#x3D; template.replace(&#x2F;\&#123;(\d)\&#125;&#x2F;g,(...arg)&#x3D;&gt;&#123;</span><br><span class="line">let [,index] &#x3D; arg &#x2F;&#x2F;index:每次正则匹配小分组捕获的结果（也就是那个数字）</span><br><span class="line">    return arr[index];</span><br><span class="line">&#125;)</span><br><span class="line">console.log(template)</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/24/UxlJSO.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="RegExp" scheme="http://yoursite.com/categories/RegExp/"/>
    
    
      <category term="RegExp" scheme="http://yoursite.com/tags/RegExp/"/>
    
  </entry>
  
  <entry>
    <title>flex是什么？flex：1表示什么？</title>
    <link href="http://yoursite.com/2020/07/24/12-flex%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9Fflex%EF%BC%9A1%E8%A1%A8%E7%A4%BA%E4%BB%80%E4%B9%88%EF%BC%9F/"/>
    <id>http://yoursite.com/2020/07/24/12-flex%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9Fflex%EF%BC%9A1%E8%A1%A8%E7%A4%BA%E4%BB%80%E4%B9%88%EF%BC%9F/</id>
    <published>2020-07-24T14:36:56.000Z</published>
    <updated>2020-07-25T15:37:57.639Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>flex是三个属性的缩写，分别是flex-grow、flex-shrink、flex-basis。</p><p><strong>flex-grow表示项目的放大比例</strong></p><p>:one:默认为0，即使存在剩余空间也不会放大</p><p>:two:所有项目的flex-grow为1时，等分剩余空间</p><p>:three:flex-row为n的项目，占据的空间（放大的比例）是flex-grow为1的n倍</p><h5 id="flex-shrink表示项目的缩小比例"><a href="#flex-shrink表示项目的缩小比例" class="headerlink" title="flex-shrink表示项目的缩小比例"></a><strong>flex-shrink表示项目的缩小比例</strong></h5><p>:one:默认为1，当空间不足时，项目会自动缩小</p><p>:two:flex-shrink为0时，空间不足，项目不会缩小</p><p>:three: flex-shrink为n的项目，空间不足时缩小的比例是flex-shrink为1的n倍</p><h5 id="flex-basis表示在分配剩余空间之前，项目所占据的主轴空间大小"><a href="#flex-basis表示在分配剩余空间之前，项目所占据的主轴空间大小" class="headerlink" title="flex-basis表示在分配剩余空间之前，项目所占据的主轴空间大小"></a><strong>flex-basis表示在分配剩余空间之前，项目所占据的主轴空间大小</strong></h5><p>:one:默认为auto，即项目本身的大小</p><p>:two:设置后项目将占据固定空间</p><p>所以flex属性的默认值为：0 1 auto （不放大会缩小）</p><p>  <strong>flex为none</strong>：0 0 auto  （不放大也不缩小）</p><p>  <strong>flex为auto</strong>：1 1 auto  （放大且缩小）</p><p>因此flex：1即为flex-grow：1，经常用作自适应布局，将父容器的display：flex，侧边栏大小固定后，将内容区flex：1，内容区则会自动放大占满剩余空间。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="CSS" scheme="http://yoursite.com/categories/CSS/"/>
    
    
      <category term="CSS" scheme="http://yoursite.com/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>输出下面代码运行结果</title>
    <link href="http://yoursite.com/2020/07/23/10-%E8%BE%93%E5%87%BA%E4%B8%8B%E9%9D%A2%E4%BB%A3%E7%A0%81%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C/"/>
    <id>http://yoursite.com/2020/07/23/10-%E8%BE%93%E5%87%BA%E4%B8%8B%E9%9D%A2%E4%BB%A3%E7%A0%81%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C/</id>
    <published>2020-07-23T11:35:23.000Z</published>
    <updated>2020-07-23T13:28:42.223Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>输出下面代码运行结果</p><p>example 1</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var a &#x3D; &#123;&#125;，b&#x3D;&#39;123&#39;,c&#x3D;123;</span><br><span class="line">a[b]&#x3D;&#39;b&#39;;</span><br><span class="line">a[c]&#x3D;&#39;c&#39;;</span><br><span class="line">console.log(a[b]);</span><br></pre></td></tr></table></figure><p>example 2</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var a &#x3D; &#123;&#125;，b&#x3D;Symbol(&#39;123&#39;),c&#x3D;Symbol(&#39;123&#39;);</span><br><span class="line">a[b]&#x3D;&#39;b&#39;;</span><br><span class="line">a[c]&#x3D;&#39;c&#39;;</span><br><span class="line">console.log(a[b]);</span><br></pre></td></tr></table></figure><p>example 3</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var a &#x3D; &#123;&#125;，b&#x3D;&#123;key:&#39;123&#39;&#125;,c&#x3D;&#123;key:&#39;456&#39;&#125;;</span><br><span class="line">a[b]&#x3D;&#39;b&#39;;</span><br><span class="line">a[c]&#x3D;&#39;c&#39;;</span><br><span class="line">console.log(a[b]);</span><br></pre></td></tr></table></figure><p>答案：</p><ol><li><p>c  =&gt; 因为a[‘123’] == a[123]</p></li><li><p>b  =&gt;Symbol是ES6中新增的数据类型，typeof Smybol(‘123’) === Smybol,它创建出的值是唯一的</p><p>Smybol(‘123’) =！Smybol(‘123’) </p></li><li><p>c =&gt;  对象的属性名不能是一个对象，若是对象属性名，会默认转换为字符串</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">obj&#x3D;&#123;&#125; arr&#x3D;[11,22] obj[arr]&#x3D;33  obj&#x3D;&gt;&#123;&#39;11,22&#39;:33&#125;</span><br></pre></td></tr></table></figure><p>普通对象.toString() 调取的是Object.prototype上的方法(这个方法是用来检测数据类型的)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">obj&#x3D;&#123;&#125; obj.toString()&#x3D;&gt;&#39;[Object Object]&#39;</span><br><span class="line">obj[b]&#x3D;&#39;b&#39; &#x3D;&gt; obj[&#39;[Object Object]&#39;]&#x3D;&#39;b&#39;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
    
      <category term="prototype" scheme="http://yoursite.com/tags/prototype/"/>
    
      <category term="Symbol" scheme="http://yoursite.com/tags/Symbol/"/>
    
  </entry>
  
  <entry>
    <title>实现(5).add(3).minus(2)，使其结果为6</title>
    <link href="http://yoursite.com/2020/07/22/07-%E5%AE%9E%E7%8E%B0(5).add(3).minus(2)/"/>
    <id>http://yoursite.com/2020/07/22/07-%E5%AE%9E%E7%8E%B0(5).add(3).minus(2)/</id>
    <published>2020-07-22T12:35:23.000Z</published>
    <updated>2020-07-22T12:31:37.222Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">~function()&#123;</span><br><span class="line">&#x2F;&#x2F;每一个方法执行完，都要返回Number这个类的实例，这样才可以继续调取Number类原型中的方法</span><br><span class="line">function check(n)&#123;</span><br><span class="line">n &#x3D; Nunber(n);</span><br><span class="line">return isNaN(n)?0:n;</span><br><span class="line">&#125;</span><br><span class="line">function add(n)&#123;</span><br><span class="line">n &#x3D; check(n);</span><br><span class="line">return this+n;</span><br><span class="line">&#125;</span><br><span class="line">functino minus(n)&#123;</span><br><span class="line">n &#x3D; check(n);</span><br><span class="line">return this-n;</span><br><span class="line">&#125;</span><br><span class="line">Number.prototype.add &#x3D; add;</span><br><span class="line">Number.prototype.minus &#x3D; minus;</span><br><span class="line">&#x2F;*[add,minus].foreach(item&#x3D;&gt;&#123;</span><br><span class="line">Number.prototype[item]&#x3D;eval(item)</span><br><span class="line">&#125;)*&#x2F;</span><br><span class="line">&#125;();</span><br><span class="line">(5).add(3).minus(2)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="JS算法" scheme="http://yoursite.com/categories/JS%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="JS算法" scheme="http://yoursite.com/tags/JS%E7%AE%97%E6%B3%95/"/>
    
      <category term="prototype" scheme="http://yoursite.com/tags/prototype/"/>
    
  </entry>
  
  <entry>
    <title>如何把一个字符串的大小写取反</title>
    <link href="http://yoursite.com/2020/07/22/06-%E5%A6%82%E4%BD%95%E6%8A%8A%E4%B8%80%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%A4%A7%E5%B0%8F%E5%86%99%E5%8F%96%E5%8F%8D/"/>
    <id>http://yoursite.com/2020/07/22/06-%E5%A6%82%E4%BD%95%E6%8A%8A%E4%B8%80%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%A4%A7%E5%B0%8F%E5%86%99%E5%8F%96%E5%8F%8D/</id>
    <published>2020-07-22T12:28:08.000Z</published>
    <updated>2020-07-22T12:28:54.683Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="如何把一个字符串的大小写取反（大写变小写，小写变大写）"><a href="#如何把一个字符串的大小写取反（大写变小写，小写变大写）" class="headerlink" title="如何把一个字符串的大小写取反（大写变小写，小写变大写）"></a>如何把一个字符串的大小写取反（大写变小写，小写变大写）</h2><h4 id=""><a href="#" class="headerlink" title=""></a></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let str &#x3D; &#39;hfubH就U观看dhHUd耳机的H日e就&#39;</span><br><span class="line">&#x2F;&#x2F; content:每次正则匹配的结果</span><br><span class="line">&#x2F;&#x2F;把字母转换为大写后判断是否和之前一样，若一样则要转小写</span><br><span class="line">&#x2F;&#x2F;或者在ASCII表中找大写字母的取值范围(65-90)进行判断charCodeAt</span><br><span class="line">str.replace(&#x2F;[a-zA-Z]&#x2F;g,content&#x3D;&gt;&#123;</span><br><span class="line">return content.toUpperCase() &#x3D;&#x3D;&#x3D; content? content.toLowerCase() : content.toUpperCase();</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="JS算法" scheme="http://yoursite.com/categories/JS%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="JS算法" scheme="http://yoursite.com/tags/JS%E7%AE%97%E6%B3%95/"/>
    
      <category term="字符串" scheme="http://yoursite.com/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
</feed>
