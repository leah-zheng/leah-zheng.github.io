<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Leah&#39;s blog</title>
  
  
  <link href="/leah_blog/atom.xml" rel="self"/>
  
  <link href="http://leahzheng.gitee.io/leah_blog/"/>
  <updated>2020-07-18T06:45:34.000Z</updated>
  <id>http://leahzheng.gitee.io/leah_blog/</id>
  
  <author>
    <name>Leah Zheng</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>02-fetch和axios的知识点总结</title>
    <link href="http://leahzheng.gitee.io/leah_blog/2020/07/18/02-fetch%E5%92%8Caxios%E7%9A%84%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"/>
    <id>http://leahzheng.gitee.io/leah_blog/2020/07/18/02-fetch%E5%92%8Caxios%E7%9A%84%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/</id>
    <published>2020-07-18T06:45:34.000Z</published>
    <updated>2020-07-18T06:45:34.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\leah_blog\assets\css\APlayer.min.css"><script src="\leah_blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\leah_blog\assets\js\Meting.min.js"></script><h3 id="主要知识点："><a href="#主要知识点：" class="headerlink" title="主要知识点："></a>主要知识点：</h3><ol><li>fetch是规范底层API</li><li>axios是封装</li><li>fetch和axios的优缺点</li></ol><h2 id="fetch"><a href="#fetch" class="headerlink" title="fetch"></a>fetch</h2><p>fetch是一个低层次API，可以考虑成原生的XHR，使用起来并不是很方便，需要进行封装</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fetch(&#39;http:&#x2F;&#x2F;xxx.com&#x2F;xxx.json&#39;,第二个参数指定传输方式get、post)</span><br><span class="line">.then(res&#x3D;&gt;&#123;</span><br><span class="line">return res.json();</span><br><span class="line">&#125;).then(myJson&#x3D;&gt;&#123;</span><br><span class="line">console.log(myJson)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="fetch的优势（与XMLhttpRequset相比）"><a href="#fetch的优势（与XMLhttpRequset相比）" class="headerlink" title="fetch的优势（与XMLhttpRequset相比）"></a>fetch的优势（与XMLhttpRequset相比）</h4><ol><li>语法简洁，更加语义话</li><li>基于标准Promise实现，支持async/await</li><li>更加底层，提供的Api丰富（request，response）</li><li>脱离了XHR，是ES规范里新的实现方式</li></ol><h4 id="fetch的缺点"><a href="#fetch的缺点" class="headerlink" title="fetch的缺点"></a>fetch的缺点</h4><ol><li>fetch只对网络错误请求报错，400、500都当作成功的请求</li><li>fetch默认不会带cookie，需要添加配置项：fetch(url,{credentials:’include’})</li><li>fetch不支持abort终止请求</li><li>当上传较大的文件时，fetch不支持进度的监测，axios支持</li><li>fetch api需要手动处理返回的数据</li></ol><h2 id="axios"><a href="#axios" class="headerlink" title="axios"></a>axios</h2><p>axios是基于Promise用于浏览器和nodejs的HTTP客户端，本质上也是对原生XHR(XMLhttpRequest)的封装</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">axios.get(&#39;&#x2F;user&#39;,&#123;</span><br><span class="line">params:&#123;</span><br><span class="line">id:123</span><br><span class="line">&#125;</span><br><span class="line">&#125;).then(res &#x3D;&gt; &#123;</span><br><span class="line">console.log(res)</span><br><span class="line">&#125;).catch(err &#x3D;&gt; &#123;</span><br><span class="line">console.log(err)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="axios优点"><a href="#axios优点" class="headerlink" title="axios优点"></a>axios优点</h3><ol><li>从浏览器中创建XHR</li><li>支持PromiseAPI</li><li>客户端支持防止CSRF</li><li>提供一些并发请求的接口</li><li>从node.js创建http请求</li><li>拦截请求和响应</li><li>转换请求和响应数据</li><li>可以终止请求</li><li>自动转换json数据</li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>axios既提供了并发的封装，也没有fetch的各种问题，而且体积也较小，当之无愧现在最应该选用的请求的方法。</p><p>fetch vs axios</p><ol><li><p>fetch是底层的api 浏览器原生支持的；axios是一个封装好的框架</p></li><li><p>axios  支持浏览器和nodejs前后端发请求，支持promise语法，支持自动解析json，支持中断请求，支持拦截请求，支持请求进度条检测，支持客户端防止csrf</p></li><li><p>fetch的优点是浏览器原生支持的api，原生支持promise，语法简洁，符合es标准规范，缺点是不支持文件上传进度的检测，不支持终端请求，默认不带cookie，使用不完美，需要封装</p></li></ol>]]></content>
    
    <summary type="html">
    
      fetch VS axios
    
    </summary>
    
    
      <category term="XHR" scheme="http://leahzheng.gitee.io/leah_blog/categories/XHR/"/>
    
    
      <category term="fetch" scheme="http://leahzheng.gitee.io/leah_blog/tags/fetch/"/>
    
      <category term="axios" scheme="http://leahzheng.gitee.io/leah_blog/tags/axios/"/>
    
  </entry>
  
  <entry>
    <title>如何给使用butterfly主题的hexo博客添加Valine评论功能</title>
    <link href="http://leahzheng.gitee.io/leah_blog/2020/07/17/01-valineerr/"/>
    <id>http://leahzheng.gitee.io/leah_blog/2020/07/17/01-valineerr/</id>
    <published>2020-07-17T10:07:00.000Z</published>
    <updated>2020-07-17T10:07:00.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\leah_blog\assets\css\APlayer.min.css"><script src="\leah_blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\leah_blog\assets\js\Meting.min.js"></script><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Valine简介、方便、好用的评论系统</p><p>本文总结了如何在butterfly主题的hexo博客中添加Valine评论功能</p><p>附带一下午的踩坑经验</p><h2 id="开启Valine"><a href="#开启Valine" class="headerlink" title="开启Valine"></a>开启Valine</h2><h3 id="注册leancloud"><a href="#注册leancloud" class="headerlink" title="注册leancloud"></a>注册leancloud</h3><p><a href="https://www.leancloud.cn/" target="_blank" rel="noopener">leancloud注册官网</a></p><p>注册完以后需要创建一个应用，名字可以随便起，然后 进入应用-&gt;设置-&gt;应用key</p><p>获取你的appid 和 appkey 如图所示：</p><p><img src= "/leah_blog/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/19/UWuIzR.png" alt=""></p><p>拿到你的appid和appkey之后，打开butterfly.yml主题配置文件 搜索 valine，填入appid 和 appkey</p><p>我的配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">valine:</span><br><span class="line">  enable: true</span><br><span class="line">  appId: </span><br><span class="line">  appKey: </span><br><span class="line">  notify: false </span><br><span class="line">  verify: false </span><br><span class="line">  placeholder: 欢迎留言~</span><br><span class="line">  avatar: retro</span><br><span class="line">  guest_info: nick,mail,link </span><br><span class="line">  pageSize: 10 </span><br><span class="line">  ...</span><br></pre></td></tr></table></figure><p>到这儿还没有结束，不要忘记在butterfly.yml主题配置文件中添加comments配置，博主就是忘记配置comments踩坑了一个下午，查阅了好多网友的经验文章，终于找到为什么不显示的原因，加上以下语句就可以正常显示评论面板了。</p><p><img src= "/leah_blog/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/19/UWKHpj.png" alt=""></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://blog.csdn.net/blue_zy/article/details/79071414" target="_blank" rel="noopener">为你的Hexo加上评论系统-Valine</a></p><p><a href="https://valine.js.org/avatar.html" target="_blank" rel="noopener">valine官方文档</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\leah_blog\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\leah_blog\assets\js
      
    
    </summary>
    
    
      <category term="Hexo" scheme="http://leahzheng.gitee.io/leah_blog/categories/Hexo/"/>
    
    
      <category term="Valine" scheme="http://leahzheng.gitee.io/leah_blog/tags/Valine/"/>
    
  </entry>
  
  <entry>
    <title>01-Promise知识点整理</title>
    <link href="http://leahzheng.gitee.io/leah_blog/2020/07/17/03-Promise%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/"/>
    <id>http://leahzheng.gitee.io/leah_blog/2020/07/17/03-Promise%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/</id>
    <published>2020-07-17T10:07:00.000Z</published>
    <updated>2020-07-17T10:07:00.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\leah_blog\assets\css\APlayer.min.css"><script src="\leah_blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\leah_blog\assets\js\Meting.min.js"></script><h3 id="什么是地狱回调"><a href="#什么是地狱回调" class="headerlink" title="什么是地狱回调"></a>什么是地狱回调</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$.ajax(&#123;</span><br><span class="line">url:&quot;&#x2F;.php&#x2F;ok.php&quot;,</span><br><span class="line">success:res &#x3D;&gt; &#123;</span><br><span class="line">console.log(&#39;事件1&#39;,res)</span><br><span class="line">$.ajax(&#123;</span><br><span class="line">url:&quot;&#x2F;.php&#x2F;ok.php&quot;,</span><br><span class="line">success:res &#x3D;&gt; &#123;</span><br><span class="line">console.log(&#39;事件2&#39;,res)</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="什么是Promise"><a href="#什么是Promise" class="headerlink" title="什么是Promise"></a>什么是Promise</h3><p>promise是用于表示一个异步操作最终完成（失败）及其结果的对象,用于解决地狱回调</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">let p1 &#x3D; new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">    &#x2F;&#x2F;resolve 是成功的函数</span><br><span class="line">    &#x2F;&#x2F;reject 是失败的函数</span><br><span class="line">    resolve(1)</span><br><span class="line">&#125;).then(data &#x3D;&gt; &#123;</span><br><span class="line">    console.log(&#39;成功的函数&#39;, data); &#x2F;&#x2F;成功的函数 1</span><br><span class="line">    return new Promise(resolve &#x3D;&gt; &#123;</span><br><span class="line">        resolve(&#39;传递的数值&#39;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;).then(value &#x3D;&gt; &#123;</span><br><span class="line">    console.log(&#39;接收到&#39; + value);  &#x2F;&#x2F;接收到传递的数值</span><br><span class="line">&#125;).catch(err &#x3D;&gt; &#123;</span><br><span class="line">console.log(&#39;错误的函数&#39;+err)</span><br><span class="line">&#125;)&#x2F;&#x2F;最好不要在then方法里定义reject状态的回调函数，使用catch方法,会捕捉前面所有的错误</span><br></pre></td></tr></table></figure><h3 id="封装promise函数"><a href="#封装promise函数" class="headerlink" title="封装promise函数"></a>封装promise函数</h3><p><img src= "/leah_blog/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/20/U4LDAK.png" alt=""></p><p>不停嵌套，地狱回调</p><h5 id="封装promise函数实现"><a href="#封装promise函数实现" class="headerlink" title="封装promise函数实现"></a>封装promise函数实现</h5><p><img src= "/leah_blog/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/20/U4LfBt.png" alt=""></p><h3 id="promise链式调用"><a href="#promise链式调用" class="headerlink" title="promise链式调用"></a>promise链式调用</h3><h5 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class Tast1&#123;</span><br><span class="line">then() &#123;</span><br><span class="line">console.log(1);</span><br><span class="line">return this;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">var a &#x3D; new Tast1();</span><br><span class="line">a.then().then().then() &#x2F;&#x2F; 输出3次1</span><br></pre></td></tr></table></figure><h5 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class Test2&#123;</span><br><span class="line">then() &#123;</span><br><span class="line">console.log(2);</span><br><span class="line">        return new Test2()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">let b &#x3D; new Test2();</span><br><span class="line">b.then().then().then() &#x2F;&#x2F; 输出3次2</span><br></pre></td></tr></table></figure><h3 id="事件循环"><a href="#事件循环" class="headerlink" title="事件循环"></a>事件循环</h3><h5 id="同步与异步"><a href="#同步与异步" class="headerlink" title="同步与异步"></a>同步与异步</h5><p>同步：按照从上往下顺序执行，遇到需要等待的事件会停下来等待事件完成才继续往下执行；</p><p>异步：先按照从上往下顺序执行，遇到需要等待的事件将其加入异步队列，同步任务全部完成后去异步队列中先去出所有微任务执行，执行完毕后，取出第一个宏任务，当宏任务中所有相关的微任务执行完毕后，再执行下一个宏任务</p><ol><li>宏任务(macroTask) setTimeout、setInterval, requestAnimationFrame, I/O</li><li>微任务(microTask) process,nextTick,then,objcet.observe   </li></ol><p>例题：</p><p><img src= "/leah_blog/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/20/U4I2dg.png" alt=""></p><p>结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1.同步任务</span><br><span class="line">    3</span><br><span class="line">    7</span><br><span class="line">    4</span><br><span class="line">2.微任务</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3.宏任务</span><br><span class="line">5</span><br><span class="line">resolve只执行1次，所以6不输出</span><br></pre></td></tr></table></figure><h3 id="promise的方法"><a href="#promise的方法" class="headerlink" title="promise的方法"></a>promise的方法</h3><h5 id="promise的catch"><a href="#promise的catch" class="headerlink" title="promise的catch"></a>promise的catch</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">const someAsyncthing&#x3D;()&#x3D;&gt;&#123;</span><br><span class="line">return new Promise(function(res,rej)&#123;</span><br><span class="line">下面一行会报错，因为x未定义</span><br><span class="line">resolve(x+2)</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line">someAsyncthing().catch(error&#x3D;&gt;&#123;</span><br><span class="line">console.log(&#39;this is&#39;+error)</span><br><span class="line">&#125;).then(()&#x3D;&gt;console.log(&#39;carry on&#39;))</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;this is [ReferenceError: x is not defined]</span><br><span class="line">&#x2F;&#x2F;carry on </span><br><span class="line">上面代码运行完catch()方法指定的回调函数，会接着运行后面那个then()方法指定的回调函数。如果没有报错，则会跳过catch()方法。</span><br></pre></td></tr></table></figure><h5 id="promise的finally"><a href="#promise的finally" class="headerlink" title="promise的finally"></a>promise的finally</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">finally()方法用于指定不管 Promise 对象最后状态如何，都会执行的操作。</span><br><span class="line">&#x2F;&#x2F; resolve 的值是 undefined</span><br><span class="line">Promise.resolve(2).then(() &#x3D;&gt; &#123;&#125;, () &#x3D;&gt; &#123;&#125;)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; resolve 的值是 2</span><br><span class="line">Promise.resolve(2).finally(() &#x3D;&gt; &#123;&#125;)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; reject 的值是 undefined</span><br><span class="line">Promise.reject(3).then(() &#x3D;&gt; &#123;&#125;, () &#x3D;&gt; &#123;&#125;)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; reject 的值是 3</span><br><span class="line">Promise.reject(3).finally(() &#x3D;&gt; &#123;&#125;)</span><br><span class="line"></span><br><span class="line">finally方法总是会返回原来的值</span><br></pre></td></tr></table></figure><h5 id="Promise的all和race"><a href="#Promise的all和race" class="headerlink" title="Promise的all和race"></a>Promise的all和race</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">let p1 &#x3D; new Promise(function(resolve,reject)&#123;</span><br><span class="line">resolve(1)</span><br><span class="line">&#125;)</span><br><span class="line">&#x2F;&#x2F;promise.all(数组，第二个参数函数)</span><br><span class="line">Promise.all([p1,p2,p3...]).then().catch()</span><br><span class="line">&#x2F;&#x2F;Promise.all必须数组里所有的promise对象状态都为fulfilled，才执行then的回调函数，否则执行catch()</span><br><span class="line">Promise.race([p1,p2...]).then().catch()</span><br><span class="line">&#x2F;&#x2F;只要p1、p2、p3之中有一个实例率先改变状态，p的状态就跟着改变。那个率先改变的 Promise 实例的返回值，就传递给p的回调函数。</span><br></pre></td></tr></table></figure><h5 id="promise的allsettled"><a href="#promise的allsettled" class="headerlink" title="promise的allsettled"></a>promise的allsettled</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Promise.allSettled()方法接受一组 Promise 实例作为参数，包装成一个新的 Promise 实例。只有等到所有这些参数实例都返回结果，不管是fulfilled还是rejected，包装实例才会结束。</span><br><span class="line"></span><br><span class="line">const resolved &#x3D; Promise.resolve(42);</span><br><span class="line">const rejected &#x3D; Promise.reject(-1);</span><br><span class="line"></span><br><span class="line">const allSettledPromise &#x3D; Promise.allSettled([resolved, rejected]);</span><br><span class="line"></span><br><span class="line">allSettledPromise.then(function (results) &#123;</span><br><span class="line">  console.log(results);</span><br><span class="line">&#125;);</span><br><span class="line">&#x2F;&#x2F; [</span><br><span class="line">&#x2F;&#x2F;    &#123; status: &#39;fulfilled&#39;, value: 42 &#125;,</span><br><span class="line">&#x2F;&#x2F;    &#123; status: &#39;rejected&#39;, reason: -1 &#125;</span><br><span class="line">&#x2F;&#x2F; ]</span><br></pre></td></tr></table></figure><h5 id="promise的any"><a href="#promise的any" class="headerlink" title="promise的any"></a>promise的any</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">只要参数实例有一个变成fulfilled状态，包装实例就会变成fulfilled状态；如果所有参数实例都变成rejected状态，包装实例就会变成rejected状态。</span><br></pre></td></tr></table></figure><h5 id="promise的resolve"><a href="#promise的resolve" class="headerlink" title="promise的resolve"></a>promise的resolve</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Promise.resolve(&#39;foo&#39;)</span><br><span class="line">------等价于-------</span><br><span class="line">new Promise(resolve&#x3D;&gt;resolve(&#39;foo&#39;))</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      立下了每日更新博客的flag，今天是第一天~本篇是我对promise知识点的总结
    
    </summary>
    
    
      <category term="ES6" scheme="http://leahzheng.gitee.io/leah_blog/categories/ES6/"/>
    
    
      <category term="Promise" scheme="http://leahzheng.gitee.io/leah_blog/tags/Promise/"/>
    
  </entry>
  
</feed>
